<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TGA: Starting search</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="page_2">Starting search</a></h1>All program actions start in <code><a class="el" href="main_8cc.html#a6">main()</a></code> function defined in <code><a class="el" href="main_8cc.html">main.cc</a></code>. <h2><a class="anchor" name="page_2__sec_1">
After the start</a></h2>
At first, program arguments are parsed and variables corresponding to parameters are set to their proper values ( by calling <code><a class="el" href="classParams__manager.html#a23">Params_manager::set_variable()</a></code> ). After this, program chooses one of two possible continuations :<ul>
<li>Single position search mode. This is the most commonly used mode. The algorithm simply calls <code><a class="el" href="main_8cc.html#a3">handle_single_problem()</a></code> function, which takes care of proper actions in a single problem tree search.</li><li>Multiple positions search mode. The program opens a file with problem names and then goes through them and on each one of them calls function <code><a class="el" href="main_8cc.html#a3">handle_single_problem()</a></code>. The difference with single position mode is also in the output: e.g. the information about group status, time of search are differently formated.</li></ul>
<h2><a class="anchor" name="page_2__sec_2">
Handling a single problem</a></h2>
This task is done by function <code><a class="el" href="main_8cc.html#a3">handle_single_problem()</a></code> and consists of:<ul>
<li>the initialization of possible persistent transposition tables ( when nor <code>-ntt</code> neither <code>-nst</code> options are given ) <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a4">get_transposition_tables</a>() &amp;&amp; <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a3">get_save_tt</a>()) { 
  <a class="code" href="main_8h.html#a6">t_searcher</a>.<a class="code" href="classT__searcher.html#o0">hash_table_manager</a>.<a class="code" href="classHash__table__manager.html#a1">hash_table_activate</a>(); <span class="comment">// hash table is initialized</span>
  <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o2">hash_board_manager</a>.<a class="code" href="classHash__board__manager.html#a7">init_hash_board</a>();   
}
</pre></div></li><li>covering neccessary prints</li><li>analysing the single position for the attacker moving first and then for the defender moving first ( if their moves aren't blocked by given argument ). Example of "defender moving first" section: <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a10">get_defender_moves_first</a>() ) { <span class="comment">// defender moving first </span>
  ...  <span class="comment">// output prints</span>
  status_de = <a class="code" href="main_8cc.html#a2">analyze_single_position</a> (  filename , sc_white);

  <a class="code" href="main_8cc.html#a4">print_group_status</a> ( sc_white , status_de );
}
</pre></div></li></ul>
<h2><a class="anchor" name="page_2__sec_3">
Analysing single position</a></h2>
By the term analysing single position is meant to search a problem with a specified color to move first ( attacker or defender ). This task is performed by function <code><a class="el" href="main_8cc.html#a2">analyze_single_position()</a></code> and consists of three main steps :<ul>
<li>initialization of data structures: <div class="fragment"><pre class="fragment"><a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a1">init</a>();
<a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a0">init</a>();
... <span class="comment">// potential init of transposition tables if these are switched on</span>
</pre></div></li><li>parsing sgf source of the input position <div class="fragment"><pre class="fragment"><a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a5">parse_sgf</a>( pos_name.c_str()); <span class="comment">// parsing sgf input </span>
 <span class="comment">//board initialization from temporar data structure follows</span>
<a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a14">init_from_temp_board_manager</a>( 
  <a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a7">get_temp_board_manager</a>()); 
</pre></div></li><li>performing search itself ( for a certain player playing first - see parameters of function <code><a class="el" href="main_8cc.html#a2">analyze_single_position()</a></code>) Here must be distinguished whether the option <code>-id</code> ( iterative deepening depth first search ) is switched on. If it is, search is performed in the cycle with iteratively increasing maximal depth of the search, until certain status ( the accuracy of the status is <code>gsa_certain</code> ) is not obtained. <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a16">get_iddfs</a>() ) { <span class="comment">// iddfs activated</span>
  <span class="keywordflow">while</span> (( result.group_status_accuracy != <a class="code" href="t__search_8h.html#a13a6">gsa_certain</a>)){ <span class="comment">// iterative search</span>
    ...
    <span class="keywordflow">switch</span> ( color_to_move ) {
      <span class="keywordflow">case</span> sc_white: 
        <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#a0">set_output</a> (save_filename);
        result = <a class="code" href="main_8h.html#a6">t_searcher</a>.<a class="code" href="classT__searcher.html#a0">search</a>(nt_max, 0 , <a class="code" href="eyes_8h.html#a11a1">gs_dead</a>, <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>, <span class="keyword">false</span>,<span class="keyword">false</span>);
        <span class="keywordflow">break</span>;
      .. <span class="comment">//symetrically for sc_black</span>
    }
    <a class="code" href="main_8h.html#a6">t_searcher</a>.<a class="code" href="classT__searcher.html#a7">increase_max_depth</a>(); <span class="comment">// increase maximal depth of the next search</span>
}
</pre></div></li></ul>
<p>
If no iddfs is demanded only a single search is performed and afterwards the information on the number of searched nodes together with search time is printed.<p>
All program actions start in <a class="el" href="main_8cc.html#a6">main()</a> function defined in <code><a class="el" href="main_8cc.html">main.cc</a></code>. <h2><a class="anchor" name="page_2__sec_1">
After the start</a></h2>
At first, program arguments are parsed and variables corresponding to parameters are set to their proper values ( by calling <a class="el" href="classParams__manager.html#a23">Params_manager::set_variable()</a> ). After this, program chooses one of two possible continuations :<ul>
<li>Single position search mode. This is the most commonly used mode. The algorithm simply calls <a class="el" href="main_8cc.html#a3">handle_single_problem()</a> function, which takes care of proper actions in a single problem tree search.</li><li>Multiple positions search mode. The program opens a file with problem names and then goes through them and on each one of them calls function <a class="el" href="main_8cc.html#a3">handle_single_problem()</a>. The difference with single position mode is also in the output: the information about group status, time of search, ... are differently formated.</li></ul>
<h2><a class="anchor" name="page_2__sec_2">
Handling a single problem</a></h2>
This task is done by function <a class="el" href="main_8cc.html#a3">handle_single_problem()</a> and consists of:<ul>
<li>the initialization of possible persistent transposition tables ( when <code>-tt</code> and <code>-st</code> options are given ) <div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a4">get_transposition_tables</a>() &amp;&amp; <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a3">get_save_tt</a>() ) { <span class="comment">// transposition tables and their persistency are switched on </span>
      <a class="code" href="main_8h.html#a6">t_searcher</a>.<a class="code" href="classT__searcher.html#o0">hash_table_manager</a>.<a class="code" href="classHash__table__manager.html#a1">hash_table_activate</a>();  <span class="comment">// hash table and hash keys for board is initialized once for both searches</span>
      <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o2">hash_board_manager</a>.<a class="code" href="classHash__board__manager.html#a7">init_hash_board</a>();   
    }
</pre></div></li><li>covering neccessary prints</li><li>analysing the single position ( that means it is decided who makes the first move ) for the attacker moving first and then for the defender moving first ( if their moves aren't blocked by given argument ). Example of "defender moving first" section: <div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a10">get_defender_moves_first</a>() ) { <span class="comment">// defender moving first is not blocked </span>
    ...  <span class="comment">// output prints</span>
    status_de = <a class="code" href="main_8cc.html#a2">analyze_single_position</a> (  filename , sc_white);
    ...  <span class="comment">// output prints</span>
    <a class="code" href="main_8cc.html#a4">print_group_status</a> ( sc_white , status_de );
  }
</pre></div></li></ul>
<h2><a class="anchor" name="page_2__sec_3">
Analysing single position</a></h2>
By the term analysing single position is meant to search a problem with a specified color to move first ( attacker or defender ). This task is performed by function <a class="el" href="main_8cc.html#a2">analyze_single_position()</a> and consists of three main steps :<ul>
<li>initialization of data structures: <div class="fragment"><pre class="fragment">      <a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a1">init</a>();
      <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a0">init</a>();
      ... <span class="comment">// potential init of transposition tables dependent on set parameters </span>
</pre></div></li><li>parsing sgf source of the input position <div class="fragment"><pre class="fragment">    <a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a5">parse_sgf</a>( pos_name.c_str() ); <span class="comment">// parses sgf input and saves it to temp_board_manager</span>
    <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a14">init_from_temp_board_manager</a>( <a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a7">get_temp_board_manager</a>() ); <span class="comment">// correctly inits board_manager from temp_board_maanger</span>
</pre></div></li><li>performing search itself ( for a certain player playing first - see parameters of function <a class="el" href="main_8cc.html#a2">analyze_single_position()</a> ) Here must be distinguished whether option <code>-id</code> ( iterative deepening depth first search ) is switched on. If it is, search is performed in the cycle with iteratively increasing maximal depth of the search, until certain status ( the accuracy of the status is  gsa_certain ) is not obtained.<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a16">get_iddfs</a>() ) { <span class="comment">// iddfs activated</span>
      <span class="keywordflow">while</span> ( ( result.group_status_accuracy != <a class="code" href="t__search_8h.html#a13a6">gsa_certain</a>) ) { <span class="comment">// iterative search </span>
            ...
            <span class="keywordflow">switch</span> ( color_to_move ) {
            <span class="keywordflow">case</span> sc_white: <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#a0">set_output</a> (save_filename);
                           result = <a class="code" href="main_8h.html#a6">t_searcher</a>.<a class="code" href="classT__searcher.html#a0">search</a>(nt_max, 0 , <a class="code" href="eyes_8h.html#a11a1">gs_dead</a>, <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>, <span class="keyword">false</span>,<span class="keyword">false</span>); <span class="keywordflow">break</span>;
            ... <span class="comment">//symetrically for sc_black</span>
            }
          <a class="code" href="main_8h.html#a6">t_searcher</a>.<a class="code" href="classT__searcher.html#a7">increase_max_depth</a>(); <span class="comment">// increase maximal depth of search</span>
      }
</pre></div></li></ul>
<p>
If no iddfs is demanded only a single search is performed and afterwards the information on the number of searched nodes together with search time is provided. <hr size="1"><address style="align: right;"><small>Generated on Wed May 24 10:11:22 2006 for TGA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
