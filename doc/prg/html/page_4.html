<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TGA: Static eye recognition</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="page_4">Static eye recognition</a></h1>Static eye recognition is dealt in quite a simple way in TGA. It is implemented in <code><a class="el" href="eyes_8h.html">eyes.h</a></code> and <code><a class="el" href="eyes_8cc.html">eyes.cc</a></code> and the most important class handling static analysis is <code><a class="el" href="classEye__manager.html">Eye_manager</a></code>. <h2><a class="anchor" name="page_4__sec_1">
Recognizing status of the group</a></h2>
Generally, the method of static analysis is performed in ( almost ) every node ( calling <code><a class="el" href="classEye__manager.html#a1">Eye_manager::get_group_status()</a></code> method ) and can be described as follows:<ul>
<li>For every potential eye it's <code><a class="el" href="eyes_8h.html#a12">Eye_status</a></code> is found. Meaning of possible <code><a class="el" href="eyes_8h.html#a12">Eye_status</a></code> values is clear, maybe except for <code>es_produces_no_eye</code>. This status expresses that given coordinate is not a potential eye ( usually adjacent point to attacker's unsafe stones - defender must play here to capture the attacker and therefore it is not a potential eye), but it is not clear false eye ( it might become a potential eye in the future when unsafe attacker plays here and then gets captured ). Therefore it deserves an own <code><a class="el" href="eyes_8h.html#a12">Eye_status</a></code> and particular treatment ( it is not excluded from the potential eyes set, but in actual static analysis it is not counted as a potential eye ). Points that obtain status <code>es_false_eye</code> are expelled from the list of potential eyes.</li><li>If there are two or more full eyes their connectivity is checked and ( if they are connected ) group is stated alive <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( full_eyes_num &gt;= 2 ) 
  <span class="keywordflow">if</span> ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a30">check_eyes_connection</a> ( full_eyes_set))
    <span class="keywordflow">return</span> <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>; <span class="comment">// At least two full eyes are connected</span>
</pre></div></li><li>If there are less than two potential eye producing points, group is stated dead. <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( pot_eye_map_pt_-&gt;size() - produces_no_eye_num &lt; 2)  
  <span class="keywordflow">return</span> <a class="code" href="eyes_8h.html#a11a1">gs_dead</a>;
</pre></div></li><li>If none of the previous happens, simple heuristic is tried: if group has only two potential eyes ( not counting points that gained status <code>es_produces_no_eye</code>) and these are adjacent, then group is dead ( there cannot arise two eyes ). <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (( pot_eye_map_pt_-&gt;size() - produces_no_eye_num) == 2)
  <span class="keywordflow">if</span> ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a22">check_coordinates_adjacency</a>( coordinates_1, coordinates_2)) 
    <span class="keywordflow">return</span> <a class="code" href="eyes_8h.html#a11a1">gs_dead</a>; <span class="comment">//two potential eyes and they are adjacent =&gt; group is dead</span>
</pre></div></li><li>Otherwise ( what happens in most cases ) group is stated unknown.</li></ul>
<h2><a class="anchor" name="page_4__sec_2">
Recognizing status of the potential eye</a></h2>
This is not very algorithmically difficult operation but quite a lot of cases must be handled. Here very important role is played by <code>point_board_</code> which is used to find out whether a particular coordinates is empty ( <code>ps_empty</code> ) or is occupied by defender's stone ( <code>ps_de</code> ) or attacker's stone ( safe attacker <code>ps_at</code> x unsafe attacker <code>ps_uns_at</code> ). Checking what eye status potential eye has consist of three steps:<ul>
<li>checking whether the eye point itself is empty or ocuppied by unsafe attacker</li><li>checking adjacent coordinates</li><li>checking diagonal coordinates</li></ul>
<p>
First two items are very easy and the only problem is how to perform checking of the diagonal coordinates. Since there is a possibility of so called "diagonal related eyes" ( two eyes which are diagonal points to each other ). Here is neccessary piece of recursion: when an eye seems to be potential diagonal eye ( all adjacent neighbours are defender's stones and there is an empty diagonal point which occupied by safe attacker destroys the eye and occupied by defender ( or becoming "diagonal related eye" ) creates full eye ) the recursive calling of <code><a class="el" href="classEye__manager.html#a0">Eye_manager::get_eye_status()</a></code> with <code>check_diagonal_eye</code> parameter set to true is performed. When this recursive calling ( parametr <code>check_diagonal_eye</code> prevents cycling and also states full eye on actual eye point when there is a potential diagonal eye ( the one recursive calling was perfrormed from )) returns <code>gs_full_eye</code> than both diagonal related eyes are full_eyes.<p>
Static eye recognition is dealt in quite a simple way in TGA. It is implemented in <code><a class="el" href="eyes_8h.html">eyes.h</a></code> and <code><a class="el" href="eyes_8cc.html">eyes.cc</a></code> and the most important class handling static analysis is <a class="el" href="classEye__manager.html">Eye_manager</a>. <h2><a class="anchor" name="page_4__sec_1">
Recognizing status of the group</a></h2>
Generally, the method of static analysis is performed in ( almost ) every node ( calling <a class="el" href="classEye__manager.html#a1">Eye_manager::get_group_status()</a> method ) and can be described as follows:<ul>
<li>For every potential eye it's <a class="el" href="eyes_8h.html#a12">Eye_status</a> is found. Meaning of possible <a class="el" href="eyes_8h.html#a12">Eye_status</a> values is clear, maybe except for <code>es_produces_no_eye</code>. This status expresses that given coordinate is not a potential eye ( usually adjacent point to attacker's unsafe stones - defender must play here to capture the attacker and therefore it is not a potential eye ), but it is not clear false eye ( it might become a potential eye in the future when unsafe attacker plays here and then gets captured ). Therefore it deserves an own <a class="el" href="eyes_8h.html#a12">Eye_status</a> and particular treatment ( it is not excluded from the potential eyes set, but in actual static analysis it is not counted as a potential eye ). Points that obtain status <code>es_false_eye</code> are expelled from the list of potential eyes.</li><li>If there are two or more full eyes their connectivity is checked and ( if they are connected ) group is stated alive <div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> ( full_eyes_num &gt;= 2 ) 
        <span class="keywordflow">if</span> ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a30">check_eyes_connection</a> ( full_eyes_set ) ) <span class="comment">// At least two eyes are connected</span>
          <span class="keywordflow">return</span> <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>;
</pre></div></li><li>If there are less than two potential eye producing points, group is stated dead. <div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span>  ( pot_eye_map_pt_-&gt;size() - produces_no_eye_num &lt; 2 )  
      <span class="keywordflow">return</span> <a class="code" href="eyes_8h.html#a11a1">gs_dead</a>;
</pre></div></li><li>If none of the previous happens, simple heuristic is tried: if group has only two potential eyes ( not counting points that gained status <code>es_produces_no_eye</code>) and these are adjacent, then group is dead ( there cannot arise two eyes ). <div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( ( pot_eye_map_pt_-&gt;size() - produces_no_eye_num ) == 2 )
      <span class="keywordflow">if</span> ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a22">check_coordinates_adjacency</a> ( coordinates_1 , coordinates_2 ) ) <span class="comment">// checking whether two potential eyes are adjacent</span>
            <span class="keywordflow">return</span> <a class="code" href="eyes_8h.html#a11a1">gs_dead</a>;
</pre></div></li><li>Otherwise ( what happens in most cases ) group is stated unknown.</li></ul>
<h2><a class="anchor" name="page_4__sec_2">
Recognizing status of the potential eye</a></h2>
This is not very algorithmically difficult operation but quite a lot of cases must be handled. Here very important role is played by <code>point_board_</code> which is used to find out whether a particular coordinates is empty ( <code>ps_empty</code> ) or is occupied by defender's stone ( <code>ps_de</code> ) or attacker's stone ( safe attacker <code>ps_at</code> x unsafe attacker <code>ps_uns_at</code> ). Checking what eye status potential eye has consist of three steps:<ul>
<li>checking whether the eye point itself is empty or ocuppied by unsafe attacker</li><li>checking adjacent coordinates</li><li>checking diagonal coordinates</li></ul>
<p>
First two items are very easy and the only problem is how to perform checking of the diagonal coordinates.Since there is a possibility of so called "diagonal related eyes" ( two eyes which are diagonal points to each other ). Here is neccessary piece of recursion: when an eye seems to be potential diagonal eye ( all adjacent neigbours are defender's stone and there is an empty diagonal point which occupied by safe attacker destroys the eye and occupied by defender ( or becoming "diagonal related eye" ) creates full eye ) the recursive calling of <a class="el" href="classEye__manager.html#a0">Eye_manager::get_eye_status()</a> with <code>check_diagonal_eye</code> parameter set to true is performed. When this recursive calling ( parametr <code>check_diagonal_eye</code> prevents cycling and also states full eye on actual eye point when there is a potential diagonal eye ( the one recursive calling was perfrormed from ) ) returns <code>gs_full_eye</code> than both diagonal related eyes are full_eyes. <hr size="1"><address style="align: right;"><small>Generated on Wed May 24 10:11:22 2006 for TGA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
