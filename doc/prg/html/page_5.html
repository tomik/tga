<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TGA: Sgf parsing</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="page_5">Sgf parsing</a></h1>Parsing sgf input is handled in <code><a class="el" href="sgf__read_8cc.html">sgf_read.cc</a></code> and <code><a class="el" href="sgf__read_8h.html">sgf_read.h</a></code>.<h2><a class="anchor" name="page_5__sec_1">
Sgf format</a></h2>
The sgf inner structure is very logical and easy to parse. Plain text in sgf source might be interpreted as one of followings:<ul>
<li>Special characters ( as for instance "[", "]" , ";" , ... ) create structure of the sgf source ( e.g. outline variants, show where data and tokens start )</li><li>Tokens are plain text not enclosed in square brackets. Their function is to correctly interpret data that are connected with them.</li><li>Data are plain text enclosed in square brackets and they provide information about the position.</li></ul>
<p>
Example 1: <div class="fragment"><pre class="fragment"> B[aa] 
</pre></div><p>
<ul>
<li>"B" in this example is a token for "Black's move" ( that means that data related to this section are interpreted as a move played by black )</li><li>"[" and "]" are special characters to mark up data section</li><li>"aa" are data related to "B" token and express coordinates on which black played ( here it is [0,0] ).</li></ul>
<p>
Example 2: <div class="fragment"><pre class="fragment"> (;GM[1]FF[4]CA[UTF-8]AP[CGoban:2]ST[2]RU[Japanese]SZ[11]KM[0.00] 
 CR[ga]AW[bb][cb][eb][fb][ac][bc][cc][dc]
 AB[da][db][gb][ec][fc][gc][ad][bd][cd][dd][fe] SQ[aa][ba][ca][da][ea][fa][ab][db]) 
</pre></div><p>
This is an example of the whole position written in sgf.<h2><a class="anchor" name="page_5__sec_2">
Parsing automata</a></h2>
Class <code><a class="el" href="classSgf__parser.html">Sgf_parser</a></code> represents finite automata managing sgf parsing. Set of possible automata's states is represented by <code><a class="el" href="sgf__read_8h.html#a7">Parser_state</a></code> enum. State function is simulated by a vector ( <code>State_function_vector</code> ) where each item is instance of <code><a class="el" href="classState__function__record.html">State_function_record</a></code>. Automata changes state when there comes a special character in sgf input and there exists an adequate record in the state function ( <code><a class="el" href="classSgf__parser.html#r1">Sgf_parser::state_function</a></code> ). Moving from one state to another is implemented in a straigt way: if there is a record for actual state of automata and actual character in sgf input ( this is found out with simple operator == for <code><a class="el" href="classState__function__record.html">State_function_record</a></code> ) then new state is resolved from actual record in state function.<p>
<a class="anchor" name="page_5__resolving_new_state"></a> <div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( State_function_vector::iterator it = state_function.begin(); 
      it != state_function.end(); it++)  <span class="comment">// search state function vector</span>
  <span class="comment">//checking existence of the record in the table. Third parameter is unimportant </span>
  <span class="keywordflow">if</span> ( <a class="code" href="classState__function__record.html">State_function_record</a>( actual_state, act_char , actual_state ) == (*it) ) { 
  found_ = <span class="keyword">true</span>;               <span class="comment">// a record was found </span>
  new_state_ = (*it).get_new_state(); <span class="comment">// retrieve new state </span>
  <span class="keywordflow">break</span>; 
  }

  <span class="keywordflow">if</span> ( found_ ) {
    actual_state = new_state_; <span class="comment">//set up a new state</span>
    ...
</pre></div><h2><a class="anchor" name="page_5__sec_3">
Parsing proccess</a></h2>
The result of sgf parsing is <code><a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a></code> which serves for setting up a position in <code><a class="el" href="classBoard__manager.html">Board_manager</a></code> ( that is done by <code><a class="el" href="classBoard__manager.html#a14">Board_manager::init_from_temp_board_manager()</a></code> function ).<p>
Process of sgf input parsing is conducted by <code><a class="el" href="classSgf__parser.html#a5">Sgf_parser::parse_sgf</a></code>. Function goes through input sgf file character by character ( white characters are skipped ) and actual values are worked out by function <code><a class="el" href="classSgf__parser.html#a4">Sgf_parser::resolve</a></code>.<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a4">resolve</a>(act_char, act_text ) ) 
  act_text.clear(); <span class="comment">// it is significant character [ , ] , ; , ... </span>
<span class="keywordflow">else</span>              
  act_text += act_char; <span class="comment">// it is not significant character- part of token or data </span>
</pre></div><p>
Variable <code>act_text</code> represents actually read part of text ( actual token name, actual data, ... ). If actual character is a significant one, <code>act_text</code> is worked up in <code><a class="el" href="classSgf__parser.html#a4">Sgf_parser::resolve</a></code> and thus it is cleared and ready for the next use.<p>
Function <code><a class="el" href="classSgf__parser.html#a4">Sgf_parser::resolve</a></code> manages automata transitions and <code><a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a></code> filling. At first it founds adequate transition in <code><a class="el" href="classSgf__parser.html#r1">Sgf_parser::state_function</a></code> vector ( see <a class="el" href="page_5.html#page_5__resolving_new_state">resolving new state</a> ). When there is no such a transition it means that actual character <code>act_char</code> has no significant meaning in the sgf structure and function returns <code>false</code> ( thus reading sgf input proceeds ). Otherwise ( possible transition was found ) new state of automata is set and actions are taken according to this state.<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( found_ ) { <span class="comment">// new transition found</span>
  actual_state = new_state_; <span class="comment">// setting up a new state </span>

  <span class="keywordflow">switch</span> ( new_state_ ) {
    <span class="keywordflow">case</span> <a class="code" href="sgf__read_8h.html#a7a5">aw_data</a>  : <span class="comment">// new state is awaiting data -&gt; actual token must be updated</span>
      <span class="keywordflow">if</span> ( ! act_text.empty() ) 
        actual_token = act_text; <span class="comment">// updating actual token</span>
        <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> <a class="code" href="sgf__read_8h.html#a7a4">aw_next_token</a> : <span class="comment">// awaiting next token -&gt; it old token must be handled</span>
      <span class="keywordflow">if</span> ( actual_token == token_adjust_b_stone ) {  <span class="comment">// putting black stone on the board</span>
        <a class="code" href="classCoordinates.html">Coordinates</a> coordinates_ = <a class="code" href="classCoordinates.html">Coordinates</a> ( act_text ); 
        <span class="comment">// storing coordinates to temporar data structure</span>
        temp_board_manager.stone_vector.push_back(<a class="code" href="classStone.html">Stone</a>(sc_black, <a class="code" href="board_8h.html#a50a21">sm_none</a>, coordinates_));
      } 
      <span class="keywordflow">if</span> ( actual_token == token_comments ) {
        temp_board_manager.comments = act_text; <span class="comment">// potential comments to the problem</span>
      }
      ...  <span class="comment">// other possible actions for different values of actual_token </span>
</pre></div><p>
Actions when handling <code>aw_data</code> state should be clear. In <code>aw_next_token</code> state last token ( <code><a class="el" href="classSgf__parser.html#r2">Sgf_parser::actual_token</a></code> ) together with it's data ( <code>act_text</code> ) is interpreted. Thus <code><a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a></code> is here filled with information about position such as in example code. Comments in the sgf file are extracted ( and saved in <code>temp_board_manager.comments</code> ) and they are printed when problem is being solved ( here might be for instance information about difficulty of the problem or problem's special features ). No other states of automata needs such a handling.<p>
Parsing sgf input is handled in <code><a class="el" href="sgf__read_8cc.html">sgf_read.cc</a></code> and <code><a class="el" href="sgf__read_8h.html">sgf_read.h</a></code>.<h2><a class="anchor" name="page_5__sec_1">
Sgf format</a></h2>
The sgf inner structure is very logical and easy to parse. Plain text in sgf source might be interpreted as one of followings:<ul>
<li>Special characters ( as for instance "[", "]" , ";" , ... ) create structure of the sgf source ( e.g. outline variants, show where data and tokens start )</li><li>Tokens are plain text not enclosed in square brackets. Their function is to correctly interpret data that are connected with them.</li><li>Data are plain text enclosed in square brackets and they provide information about the position.</li></ul>
<p>
Example 1: <div class="fragment"><pre class="fragment"> B[aa] 
</pre></div><ul>
<li>"B" in this example is a token for "Black's move" ( that means that data related to this section are interpreted as a move played by black )</li><li>"[" and "]" are special characters to mark up data section</li><li>"aa" are data related to "B" token and express coordinates on which black played ( here it is [0,0] ).</li></ul>
<p>
Example 2:<p>
<div class="fragment"><pre class="fragment"> (;GM[1]FF[4]CA[UTF-8]AP[CGoban:2]ST[2]RU[Japanese]SZ[11]KM[0.00]
  CR[ga]AW[bb][cb][eb][fb][ac][bc][cc][dc]
  AB[da][db][gb][ec][fc][gc][ad][bd][cd][dd][fe]  
  SQ[aa][ba][ca][da][ea][fa][ab][db])
</pre></div><p>
This is an example of the whole position written in sgf.<h2><a class="anchor" name="page_5__sec_2">
Parsing automata</a></h2>
Class <a class="el" href="classSgf__parser.html">Sgf_parser</a> ( also ) represents finite automata managing sgf parsing. Set of possible automata's states is represented by <a class="el" href="sgf__read_8h.html#a7">Parser_state</a> enum. State function is simulated by a vector ( State_function_vector ) where each item is instance of <a class="el" href="classState__function__record.html">State_function_record</a>. Automata changes state when there comes a special character in sgf input and there exists an adequate record in state function ( <a class="el" href="classSgf__parser.html#r1">Sgf_parser::state_function</a> ). Moving from one state to another is implemented in a straigt way: if there is a record for actual state of automata and actual character in sgf input ( this is found out with simple operator == for <a class="el" href="classState__function__record.html">State_function_record</a> ) then new state is resolved from actual record in state function.<p>
<a class="anchor" name="page_5__resolving_new_state"></a> <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> ( State_function_vector::iterator it = state_function.begin() ; it != state_function.end(); it++)  <span class="comment">// search state function vector</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classState__function__record.html">State_function_record</a>( actual_state, act_char , actual_state ) <span class="comment">// third parametr is unimportant - anything ! </span>
          == (*it) ) {
          found_ = <span class="keyword">true</span>;               <span class="comment">// a record was found</span>
          new_state_ = (*it).get_new_state(); <span class="comment">// retrieve new state</span>
          <span class="keywordflow">break</span>;
    }
  
    <span class="keywordflow">if</span> ( found_ ) {
     actual_state = new_state_; <span class="comment">//set up a new state</span>
    ...
</pre></div><h2><a class="anchor" name="page_5__sec_3">
Parsing proccess</a></h2>
The result of sgf parsing is <a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a> which serves for setting up a position in <a class="el" href="classBoard__manager.html">Board_manager</a> ( that is done by <a class="el" href="classBoard__manager.html#a14">Board_manager::init_from_temp_board_manager()</a> function ).<p>
Process of sgf input parsing is conducted by <a class="el" href="classSgf__parser.html#a5">Sgf_parser::parse_sgf</a>. Function goes through input sgf file character by character ( white characters are skipped ) and actual values are worked out by function <a class="el" href="classSgf__parser.html#a4">Sgf_parser::resolve</a>.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( <a class="code" href="main_8h.html#a3">sgf_parser</a>.<a class="code" href="classSgf__parser.html#a4">resolve</a>(act_char, act_text ) )  { 
      act_text.clear(); <span class="comment">// it is significant character [ , ] , ; , ...  </span>
    }
    <span class="keywordflow">else</span>              
      act_text += act_char; <span class="comment">// it is a usual character - part of token or data section    </span>
</pre></div><p>
Variable <code>act_text</code> represents actually read part of text ( actual token name, actual data, ... ). When actual character is a significant one, <code>act_text</code> is worked up in <a class="el" href="classSgf__parser.html#a4">Sgf_parser::resolve</a> and thus it is cleared and ready for next use.<p>
Function <a class="el" href="classSgf__parser.html#a4">Sgf_parser::resolve</a> manages automata transitions and also <a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a> filling. At first it founds adequate transition in <a class="el" href="classSgf__parser.html#r1">Sgf_parser::state_function</a> vector ( see <a class="el" href="page_5.html#page_5__resolving_new_state">resolving new state</a> ). When there is no such a transition it means that actual character <code>act_char</code> has no significant meaning in the sgf structure and function returns <code>false</code> ( thus reading sgf input proceeds ). Otherwise ( possible transition was found ) new state of automata is set and actions are taken according to this state.<p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> ( found_ ) {
       actual_state = new_state_;<span class="comment">// setting up a new state </span>
        
      <span class="keywordflow">switch</span> ( new_state_ ) {
        <span class="keywordflow">case</span> <a class="code" href="sgf__read_8h.html#a7a5">aw_data</a>  : <span class="comment">// new state is awaiting data -&gt; it means that actual token must be saved</span>
          <span class="keywordflow">if</span> ( ! act_text.empty() ) 
            actual_token = act_text; <span class="comment">// saving actual token</span>
          <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> <a class="code" href="sgf__read_8h.html#a7a4">aw_next_token</a> : <span class="comment">// awaiting next token -&gt; it means that old token and it's data ( act_text ) must be handled</span>
        
         <span class="keywordflow">if</span> ( actual_token == token_adjust_b_stone ) { 
            <a class="code" href="classCoordinates.html">Coordinates</a> coordinates_ = <a class="code" href="classCoordinates.html">Coordinates</a> ( act_text );
            temp_board_manager.stone_vector.push_back ( <a class="code" href="classStone.html">Stone</a>(sc_black, <a class="code" href="board_8h.html#a50a21">sm_none</a>, coordinates_));
         }  
         <span class="keywordflow">if</span> ( actual_token == token_comments ) {
            temp_board_manager.comments = act_text; <span class="comment">// potential comments to the problem</span>
        }
        ...  <span class="comment">// other possible actions for different values of actual_token </span>
</pre></div><p>
Actions when handling <code>aw_data</code> state should be clear. In <code>aw_next_token</code> state last token ( <a class="el" href="classSgf__parser.html#r2">Sgf_parser::actual_token</a> ) together with it's data ( <code>act_text</code> ) is interpreted. Thus <a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a> is here filled with information about position such as in example code. Comments in the sgf file are extracted ( and saved in temp_board_manager.comments ) and they are printed when problem is being solved ( here might be for instance information about difficulty of the problem or problem's special features ). No other states of automata needs such handling. <hr size="1"><address style="align: right;"><small>Generated on Wed May 24 10:11:22 2006 for TGA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
