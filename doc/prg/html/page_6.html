<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TGA: Position representation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="page_6">Position representation</a></h1>Module handling position representation is implemented in <code><a class="el" href="board_8h.html">board.h</a></code> and <code><a class="el" href="board_8cc.html">board.cc</a></code> and it is a largest one in the whole program. Tree search module requires an abstract Go board where move might be played ( and unplayed ) according to the valid rules of go. This module provides such an abstraction. It fullfills following functions :<ul>
<li>Position initialization from the results of sgf parsing.</li><li>Playing a move on given coordinates together with all neccessary actions.</li><li>Unplaying the last played move.</li><li>Providing methods supporting static heuristics.</li><li>Managing position hash keys.</li></ul>
<p>
The whole functionality the module offers is managed by class <code><a class="el" href="classBoard__manager.html">Board_manager</a></code>. However, there are many classes fulfilling specialized tasks ( e.g. <code><a class="el" href="classKo__manager.html">Ko_manager</a></code>, <code><a class="el" href="structUnplay__manager.html">Unplay_manager</a></code>, ... ) but all of these are included in <code><a class="el" href="classBoard__manager.html">Board_manager</a></code>, <code><a class="el" href="main_8h.html#a1">board_manager</a></code> is the only instance of this class defined in <code><a class="el" href="main_8h.html">main.h</a></code>.<h2><a class="anchor" name="page_6__sec_1">
How is position represented</a></h2>
Position is understood as a set of block of stones ( block is a set of connected stones of the same color and in program is represented by instance of class <code><a class="el" href="classBlock.html">Block</a></code> ). Go board is abstracted by a two dimensional array <code><a class="el" href="classBoard__manager.html#r1">Board_manager::board</a></code> where each item of this array is a pointer to the block occupying actual coordinates ( represented by class <code><a class="el" href="classCoordinates.html">Coordinates</a></code> ) or to <code>NULL</code> if there is no stone. Along with this "block oriented" representation simple two dimensional array where every item represents actual coordinate ( possible values for single coordinate are listed in <code><a class="el" href="board_8h.html#a51">Point_status</a></code> enum ) is held in <code><a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a></code> for purposes of <code><a class="el" href="classEye__manager.html">Eye_manager</a></code>. For tree search purposes it is neccessary to keep a list of coordinates where it is possible to play in actual turn ( <code><a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a></code> ) and list of potential eyes in actual turn ( <code><a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a></code> ).<h2><a class="anchor" name="page_6__sec_2">
Position initialization</a></h2>
After a successfull sgf parsing process all information neccessary for the position initialization ( position of stones and position of marks ) are stored in <code><a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a></code>. The position initialization is done by function <code><a class="el" href="classBoard__manager.html#a14">Board_manager::init_from_temp_board_manager()</a></code>. It is neccessary to create blocks ( and pointers to them in <code><a class="el" href="classBoard__manager.html#r1">Board_manager::board</a></code> ) according to the position structure. This is done by simply playing every stone on the board ( see below ) as if they were played in the game. <div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( Stone_vector::iterator it = temp_board_manager.stone_vector.begin(); 
      it != temp_board_manager.stone_vector.end(); it++) <span class="comment">//cycle through stored data</span>
  <span class="comment">// if item is a stone it is played out </span>
  <span class="keywordflow">if</span> ( ( (*it).get_stone_color() == sc_black) || ( (*it).get_stone_color() == sc_white))  
      play_a_stone( (*it).get_stone_color() , (*it).get_coordinates() ); <span class="comment">// playing</span>
</pre></div><p>
Afterwards sgf marks are handled:<ul>
<li>Some attacker's blocks are stated safe ( <code><a class="el" href="classBlock.html#r4">Block::safe</a></code> ) if it's stones doesn't have a "playable mark" ( <code><a class="el" href="board_8h.html#a50a19">sm_playable</a></code> ).</li><li>According to "playable mark" ( <code><a class="el" href="board_8h.html#a50a19">sm_playable</a></code> ), appropriate coordinates are added to the <code><a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a></code> ( empty points marked ) and <code><a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a></code> ( all marked - even unsafe attacker's stones are potential eyes). Moreover attacker's stones marked with "playable mark" are stated unsafe.</li><li><a class="el" href="classCoordinates.html">Coordinates</a> on the "edge" of the problem ( marked with <code><a class="el" href="board_8h.html#a50a20">sm_at_playable</a></code> ) are added to the map of playable moves with priorities <code><a class="el" href="board_8h.html#a52a33">pp_none</a></code> for defender ( he cannot play there ) and <code><a class="el" href="board_8h.html#a52a30">pp_low</a></code> for attacker ( attacker's playing priority here is low ).</li></ul>
<p>
Finally, <code>Board_manager::Point_board</code> is initialized by calling <code><a class="el" href="classBoard__manager.html#a15">Board_manager::fill_point_board()</a></code>.<p>
Besides some trivial variables initialization in <code><a class="el" href="classBoard__manager.html#a0">Board_manager::init</a></code> it is also neccessary to initialize mechanism for producing Zobrist hashing keys. This is done by <code><a class="el" href="classHash__board__manager.html#a7">Hash_board_manager::init_hash_board</a></code>. In this function for every possible position on the Go board an it's every possible state ( containing black or white stone - empty points are not taken into account when hashing ) a long random number is generated. Unsigned long long type ( 64 bit ) is used for these numbers. These random numbers ( organized <code>in</code> <a class="el" href="classHash__board__manager.html#r0">Hash_board_manager::hash_board</a> ) provide base for generating Zobrist hash keys for every position on the Go board and thus make engine in transposition tables and repetitions checks work ( see <a class="el" href="page_3.html">Tree search</a> ). This initialization function is run from <code><a class="el" href="main_8cc.html">main.cc</a></code> for every position to be solved.<h2><a class="anchor" name="page_6__sec_3">
Playing a move</a></h2>
This is the most complicated operation in the whole position representation. It is done by function <code><a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a></code> ( this function is "a heart" of the whole module ) supported by other <code><a class="el" href="classBoard__manager.html">Board_manager</a></code> functions. The general process can be described in three basic steps ( in function they are not strictly sequential, rather they interfere ):<ul>
<li>creating <code><a class="el" href="structUnplay__manager.html">Unplay_manager</a></code> record for future stones unplaying</li><li>adding the played stone into the block structure and updating it ( adjusting liberties, merging blocks, some block might get captured, ... )</li><li>updating other data structures ( e.g. <code><a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a></code> )</li></ul>
<p>
If move is a pass move, only shortened record is saved for unplaying purposes and function returns <code>true</code> ( playing a move was successfull ). Some trivial checks are performed afterwards it was found move is not a pass ( e.g. there is no stone on desired coordinates, it is not violating ko rule ). A complete record for unplaying is created and filled with the actual infromation.<p>
<div class="fragment"><pre class="fragment"><a class="code" href="structUnplay__node.html">Unplay_node</a> * act_node = <span class="keyword">new</span> <a class="code" href="structUnplay__node.html">Unplay_node</a>(); <span class="comment">// creating new node of dynamic list </span>
act_node-&gt;<a class="code" href="structUnplay__node.html#r0">next</a> = unplay_node_handle; <span class="comment">// adding a node to the beginning of list</span>
unplay_node_handle = act_node;
<span class="comment">//node is filled with unplaying information</span>
unplay_node_handle-&gt;<a class="code" href="structUnplay__node.html#r1">unplay_manager</a>.<a class="code" href="structUnplay__manager.html#r2">stone_to_unplay</a> = coordinates_;  
unplay_node_handle-&gt;unplay_manager.number_stones_de = number_stones_de;
... <span class="comment">// saving other datastructures: playable_man, pot_eyes_map, ko_manager, position_hash</span>
</pre></div><p>
If the move is a ko taking move ( checked by function <code>Board_manager::takes_ko</code> ), <code><a class="el" href="classBoard__manager.html#o3">Board_manager::ko_manager</a></code> is activated and filled with actual ko information ( where it takes place, which are retake coordinates, which player took the ko ). Now it comes time to add a stone into the block structure. First, new empty block is created and actual stone is added into it together with updating position hash key. <div class="fragment"><pre class="fragment"><a class="code" href="classBlock.html">Block</a> * act_block_ = <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a1">create_new_block</a>( stone_color_); <span class="comment">// creates empty block</span>
act_block_-&gt;<a class="code" href="classBlock.html#a4">add_stone</a> ( coordinates_ );  <span class="comment">// </span>
board[coordinates_.<a class="code" href="classCoordinates.html#a3">get_co_row</a>()] <span class="comment">// sets a pointer from a board to the block</span>
    [coordinates_.<a class="code" href="classCoordinates.html#a4">get_co_column</a>()].set_present_block_pt( act_block_); 
hash_board_manager.xor_with_position_hash( coordinates_, stone_color_); <span class="comment">// update hash key </span>
</pre></div><p>
Now, more complicated part comes. At first cycle through the new block's neighbouring coordinates is performed and liberties are added to the block as well as neighbour blocks of stones are saved for unplaying purposes ( see <a class="el" href="page_6.html#page_6__sec_4">Unplaying moves</a> ). Afterwards another cycle managing block structure updating is performed. It goes through new block ( actual ) neighbours again and merges actual block with neighbouring friendly blocks ( by calling <code><a class="el" href="classBoard__manager.html#a5">Board_manager::merge_blocks</a></code> ) into a single block of stones. This cycle also removes liberty from enemy neigbouring blocks and possibly performs function capturing this enemy block ( <code><a class="el" href="classBoard__manager.html#a2">Board_manager::capture_block</a></code> ) <div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 4 ; i++ ) {
  ...
  <span class="comment">// getting pointer to adjacent block </span>
  adjacent_block_ =  board[adjacent_coordinates_[i].get_co_row()]
                      [adjacent_coordinates_[i].get_co_column()].get_present_block_pt(); 

  adjacent_block_-&gt;remove_liberty( coordinates_ ); <span class="comment">// played stone removed block's liberty</span>
  <span class="keywordflow">if</span>( adjacent_block_-&gt;stone_color == stone_color_) { <span class="comment">//adjacent block is friendly one</span>
    merge_blocks(  act_block_  , adjacent_block_ ); <span class="comment">// merging adjacent and actual </span>
  }
  <span class="keywordflow">else</span> { <span class="comment">// adjacent block is an enemy one </span>
    <span class="keywordflow">if</span> ( adjacent_block_-&gt;is_captured() ) { <span class="comment">//last liberty was removed =&gt; capturing block</span>
      capture_block( adjacent_block_ );
  }
</pre></div><p>
Capturing a block ( <code><a class="el" href="classBoard__manager.html#a2">Board_manager::capture_block</a></code> ) is connected with updating the list of potential coordinates to play ( <code><a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a></code> ) and the list of potential eyes ( <code><a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a></code> - coordinates under captured stones become potential eyes ). Liberties are added to the neigbouring ( opponent's ) blocks and the position hash key is updated as well ( stones of the captured block are xored out ). At the end the block is removed by function <code><a class="el" href="classBoard__manager.html#a3">Board_manager::remove_block</a></code> ( updates pointers from <code><a class="el" href="classBoard__manager.html#r1">Board_manager::board</a></code> and items in <code><a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a></code> and destroys the block ). It is neccessary to take appropriate actions when "under the stones" treatment is switched off ( <code>-nus</code> parameter ). In that case when a defender block of at least 3 stones is captured ( expressed by variable <code>possible_under_the_stones</code> ), coordinates under the captured stones are not added to the <code><a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a></code> nor <code><a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a></code>. Thus, the algorithm doesn't try to play under them. When no "under the stones" analysis is demanded, unsafe attacker's stones that captured this defender's block are excluded from the list of potential eyes ( they cannot be captured thus are not potential eyes ). Backbone of capturing function is programmed as follows:<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( Coordinates_vector::iterator it = block_-&gt;stone_vector.begin(); 
      it &lt; block_-&gt;stone_vector.end() ; it++ )  { <span class="comment">//cycle through captured stones</span>

  <span class="comment">// if playing under the stones is not forbidden, data structures are actualized</span>
  <span class="keywordflow">if</span> (( ! possible_under_the_stones ) || ( ! <a class="code" href="main_8h.html#a2">params_manager</a>.get_no_under_the_stones())) {
    playable_map.insert ( make_pair ((*it) , <a class="code" href="classPlayable__data.html">Playable_data</a>())); <span class="comment">//playing under the stones</span>
    pot_eyes_map.insert ( make_pair ((*it) , 0 ));  
  }
  hash_board_manager.xor_with_position_hash((*it), block_-&gt;stone_color); <span class="comment">//hash key update</span>
  ... <span class="comment">// adding liberties to adjacent blocks </span>
}
remove_block( block_); <span class="comment">// destroying the block</span>
</pre></div><p>
Finally in the process of playing a stone, <code><a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a></code> and the list of potential coordinates to play ( <code><a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a></code> ) are updated according to the played stone. In the end it must be checked whether a played stone was not a suicide. If it was a suicide, stone is immediately unplayed ( thus keeping consistence of playing function ) and function returns <code>false</code> marking that move was illegal. <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( act_block_-&gt;<a class="code" href="classBlock.html#a8">is_captured</a>() ) { 
  unplay_last_stone(); <span class="comment">// stone must be prevented to commit a suicide</span>
  <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// stone was not played </span>
}
</pre></div><h2><a class="anchor" name="page_6__sec_4">
Unplaying moves</a></h2>
A single instance of <code><a class="el" href="structUnplay__manager.html">Unplay_manager</a></code> is capable of storing all information neccessary for an unplay of a single move. These instances are organized into a dynamic list in order to properly unplay all moves along the path to the actual position. Dynamic list thus consists of instances of <code><a class="el" href="structUnplay__node.html">Unplay_node</a></code> ( containig instance of <code><a class="el" href="structUnplay__manager.html">Unplay_manager</a></code> and pointer to next node ). Actually this dynamic list is backward organized ( new nodes are added to the beginning) thus nodes related to last moves are in the beginnning and those related to moves played earlier are in the end. Pointer <code>Board_manager::Unplay_node_handle</code> marks the beginning of this dynamic list. As shown above a new record ( instance of <code><a class="el" href="structUnplay__node.html">Unplay_node</a></code> ) is added to the dynamic structure in function <code><a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a></code>. Process of unplaying last played move ( another move cannot be unplayed ) is covered by function <code><a class="el" href="classBoard__manager.html#a16">Board_manager::unplay_last_stone</a></code>.<p>
Unplaying pass moves is handled at first. There are created special ( almost empty ) unplaying records for pass moves containing only information that pass was played and copy of <code><a class="el" href="classBoard__manager.html#o3">Board_manager::ko_manager</a></code> (this is neccessary because after pass it is possible to retake some ko which was forbidden before). If move is not pass, at first some data structures ( <code>playable_map</code> , <code>ko_manager</code>, <code>number_stones_de</code>, <code>pot_eyes_map</code>, <code>position_hash</code>) are just copied from the unplay record to the data structures in <code><a class="el" href="classBoard__manager.html">Board_manager</a></code>. <div class="fragment"><pre class="fragment">playable_map = unplay_node_handle-&gt;unplay_manager.playable_map; 
ko_manager = unplay_node_handle -&gt; unplay_manager.ko_manager;
... <span class="comment">// copying other data structures</span>
</pre></div><p>
Now the block structure has to be restored. In the process of playing actual stone ( the one to unplay ) algorithm stored copies of blocks neighbouring to coordinate on which stone was played ( see <a class="el" href="page_6.html#page_6__sec_3">Playing a move</a> ). Actual block and block's neigbouring to coordinate on which stone was played are simply removed ( using function <code><a class="el" href="classBoard__manager.html#a3">Board_manager::remove_block</a></code> ). Now position on the board is updated by adding stored blocks into the block structure. This is done by the cycle through all stones in every of these blocks ( maximally four neighbouring blocks ) and setting pointers from adequate coordinates in <code><a class="el" href="classBoard__manager.html#r1">Board_manager::board</a></code> to the actual block, moreover <code><a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a></code> is updated. <div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i =0 ; i &lt; FOUR ; i++ ) {
  at_block_ =  unplay_node_handle-&gt;unplay_manager.neigbour_blocks[i];
  ... 
  <span class="keywordflow">for</span> ( Coordinates_vector::iterator it = act_block_-&gt;<a class="code" href="classBlock.html#r6">stone_vector</a>.begin(); 
        it &lt; act_block_ -&gt;<a class="code" href="classBlock.html#r6">stone_vector</a>.end() ; it++ ) { <span class="comment">//cycle through</span>
     <span class="comment">// setting a pointer from Board_manager::board  </span>
    board[(*it).get_co_row()][(*it).get_co_column()].set_present_block_pt( act_block_ );
    
    <span class="comment">// updating Board_manager::point_board according to actual stone( color,safe/unsafe )</span>
    <span class="keywordflow">if</span> ( act_block_-&gt;<a class="code" href="classBlock.html#r1">stone_color</a> == sc_white )  
      point_board[(*it).get_co_row()][(*it).get_co_column()] = <a class="code" href="board_8h.html#a51a24">ps_de</a>; <span class="comment">// defender's stone</span>
    <span class="keywordflow">else</span> { <span class="comment">// handling variants for ps_at and ps_uns_at </span>
      <span class="keywordflow">if</span> ( act_block_-&gt; safe ) 
        ...
    }
</pre></div><p>
Last obstacle is that some of neighbouring blocks might got captured by playing an actual stone ( in <code><a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a></code> ). In that case all stones of this block are cycled through and liberties representing these stones ( block was captured, therefore it provided liberties for adjacent blocks ) must be removed from all adjacent blocks. Finally handler to actual stone to unplay ( <code><a class="el" href="classBoard__manager.html#o6">Board_manager::unplay_node_handle</a></code> ) is forwarded to the next item in the dynamic list ( thus list gets ready for the next unplay ) and actual <code><a class="el" href="structUnplay__node.html">Unplay_node</a></code> is destroyed.<h2><a class="anchor" name="page_6__sec_5">
Static heuristics methods</a></h2>
<code><a class="el" href="classBoard__manager.html">Board_manager</a></code> contains set of methods supporting static heuristics neccessary for efficient tree search. They are quite similar and clearly benefit from chosen "block oriented" position representation. As an example I provide detailed description of <code><a class="el" href="classBoard__manager.html#a26">Board_manager::check_take_liberty</a></code>. This function is used to check whether played move captures, ataris or simply takes away liberty of opponent's unsafe block. These different actions are distinguished by demanded number of opponent's block's liberties : 1 for capture , 2 for atari , 0 stands for more than 2 and represents simply taking away the liberty. At first it is checked whether input <code><a class="el" href="classCoordinates.html">Coordinates</a></code> are valid ( not equal to <code><a class="el" href="classCoordinates.html">Coordinates</a></code> (-1,-1 ) ). Then in the cycle neighbouring coordinates of coordinate in check are retrieved and so are the blocks of stones covering them. After neccessary trivial checks ( negihbouring coordinates are on the board, neighbouring block is present ) a simple test whether neighbouring block matches the conditions is done It matches the conditions if it is an unsafe opponent's block with an appropriate number of liberties.<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; FOUR ; i++ ) {
  <span class="comment">// obtaining neighbouring coordinates </span>
  adjacent_coordinates_ = get_adjacent_coordinates ( coordinates_ , <a class="code" href="board_8h.html#a53">Direction</a> ( i ) ); 
  <span class="keywordflow">if</span> ( <a class="code" href="classCoordinates.html">Coordinates</a> ( -1, -1 ) == adjacent_coordinates_ ) <span class="comment">// out of the board</span>
    <span class="keywordflow">continue</span>;
  adjacent_block_ = board[adjacent_coordinates_.get_co_row()] <span class="comment">// getting neighbour block</span>
                         [adjacent_coordinates_.get_co_column()].get_present_block_pt();

  <span class="comment">// if all conditions of taking the liberty away are fulfilled ...</span>
  <span class="keywordflow">if</span> ( adjacent_block_ != NULL &amp;&amp; adjacent_block_-&gt; stone_color != stone_color_ &amp;&amp; 
      ! adjacent_block_-&gt;safe &amp;&amp;    
      ( adjacent_block_-&gt;liberty_count == liberty_num_ || liberty_num_ == 0 ) )  { 
        ... <span class="comment">// here function returns pointer to block whose liberty is taken </span>
        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// test was successfull, move takes away liberty_num_ liberties</span>
  }
}
</pre></div><p>
All static heuristic methods are declared within <code><a class="el" href="classBoard__manager.html">Board_manager</a></code> and begin with a keyword "check".<p>
Module handling position representation is implemented in <code><a class="el" href="board_8h.html">board.h</a></code> and <code><a class="el" href="board_8cc.html">board.cc</a></code> and it is a largest one in the whole program. Tree search module requires an abstract Go board where move might be played ( and unplayed ) according to the valid rules of go. This module provides such an abstraction. It fullfills followinf functions :<ul>
<li>Position initialization from the results of sgf parsing.</li><li>Playing a move on given coordinates together with all neccessary actions.</li><li>Unplaying the last played move.</li><li>Providing methods supporting static heuristics.</li><li>Managing position hash keys.</li></ul>
<p>
The whole functionality the module offers is managed by class <a class="el" href="classBoard__manager.html">Board_manager</a>. However there are many classes fulfilling specialized tasks ( e.g. <a class="el" href="classKo__manager.html">Ko_manager</a>, <a class="el" href="structUnplay__manager.html">Unplay_manager</a>, ... ) but all of these are included in <a class="el" href="classBoard__manager.html">Board_manager</a>, <a class="el" href="main_8h.html#a1">board_manager</a> is the only one instance of this class defined in <code><a class="el" href="main_8h.html">main.h</a></code>.<h2><a class="anchor" name="page_6__sec_1">
How is position represented</a></h2>
Position is understood as a set of block of stones ( block is a set of connected stones of the same color and in program is represented by instance of class <a class="el" href="classBlock.html">Block</a> ). Go board is abstracted by a two dimensional array <a class="el" href="classBoard__manager.html#r1">Board_manager::board</a> where each item of this array is a pointer to the block occupying actual coordinates ( represented by class <a class="el" href="classCoordinates.html">Coordinates</a> ) or to <code>NULL</code> if there is no stone. Along with this "block oriented" representation simple two dimensional array where every item represents actual coordinate ( possible values for single coordinate are listed in <a class="el" href="board_8h.html#a51">Point_status</a> enum ) is held in <a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a> for purposes of <a class="el" href="classEye__manager.html">Eye_manager</a>. For tree search purposes it is neccessary to keep a list of coordinates where it is possible to play in actual turn ( <a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a> ) and list of potential eyes in actual turn ( <a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a> ).<h2><a class="anchor" name="page_6__sec_2">
Position initialization</a></h2>
After a successfull sgf parsing process all information neccessary for the position initialization ( position of stones and position of marks ) are stored in <a class="el" href="classSgf__parser.html#r12">Sgf_parser::temp_board_manager</a>. The position initialization is done by function <a class="el" href="classBoard__manager.html#a14">Board_manager::init_from_temp_board_manager()</a>. It is neccessary to create blocks ( and pointers to them in <a class="el" href="classBoard__manager.html#r1">Board_manager::board</a> ) according to the position structure. This is done by simply playing every stone on the board ( see below ) as if they were played in the game. <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> ( Stone_vector::iterator it = temp_board_manager.stone_vector.begin() ; it != temp_board_manager.stone_vector.end() ; it++ )
      <span class="keywordflow">if</span> ( ( (*it).get_stone_color() == sc_black ) || ( (*it).get_stone_color() == sc_white ) )  <span class="comment">// it is a stone =&gt; i ,, play it " </span>
      play_a_stone( (*it).get_stone_color() , (*it).get_coordinates() );  
</pre></div><p>
Afterwards sgf marks are handled:<ul>
<li>Some attacker's blocks are stated safe ( <a class="el" href="classBlock.html#r4">Block::safe</a> ) if it's stones doesn't have a "playable mark" ( <a class="el" href="board_8h.html#a50a19">sm_playable</a> ).</li><li>According to "playable mark" ( <a class="el" href="board_8h.html#a50a19">sm_playable</a> ), appropriate coordinates are added to the <a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a> ( empty points marked ) and <a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a> ( all marked - even unsafe attacker's stones are potential eyes). Moreover attacker's stones marked with "playable mark" are stated unsafe.</li><li><a class="el" href="classCoordinates.html">Coordinates</a> on the "edge" of the problem ( marked with <a class="el" href="board_8h.html#a50a20">sm_at_playable</a> ) are added to the map of playable moves with priorities <a class="el" href="board_8h.html#a52a33">pp_none</a> for defender ( he cannot play there ) and <a class="el" href="board_8h.html#a52a30">pp_low</a> for attacker ( attacker's playing priority here is low ).</li></ul>
<p>
Finally, Board_manager::Point_board is initialized with function <a class="el" href="classBoard__manager.html#a15">Board_manager::fill_point_board()</a>.<p>
Besides some trivial variables initialization in <a class="el" href="classBoard__manager.html#a0">Board_manager::init</a> it is also neccessary to initialize mechanism for producing Zobrist hashing keys. This is done by <a class="el" href="classHash__board__manager.html#a7">Hash_board_manager::init_hash_board</a>. In this function for every possible position on the Go board an it's every possible state ( containing black or white stone - empty points are not taken into account when hashing ) a long random number is generated. Unsigned long long type ( 64 bit ) is used for these numbers. These random numbers ( organized in <a class="el" href="classHash__board__manager.html#r0">Hash_board_manager::hash_board</a> ) provide base for generating Zobrist hash keys for every position on the Go board and thus make engine in transposition tables and repetitions checks work ( see <a class="el" href="page_3.html">Tree search</a> ). This initialization function is run from <code><a class="el" href="main_8cc.html">main.cc</a></code> for every position to be solved.<h2><a class="anchor" name="page_6__sec_3">
Playing a move</a></h2>
This is the most complicated operation in the whole position representation. It is done by function <a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a> ( this function is "a heart" of whole module ) supported by other <a class="el" href="classBoard__manager.html">Board_manager</a> functions. The general process can be described in three basic steps ( in function they are not strictly sequential, rather they interfere ):<ul>
<li>creating <a class="el" href="structUnplay__manager.html">Unplay_manager</a> record for future stones unplaying</li><li>adding the played stone into the block structure and updating it ( adjusting liberties, merging blocks, some block might get captured, ... )</li><li>updating other data structures ( e.g. <a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a>, <a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a> )</li></ul>
<p>
If move is a pass move, only shortened record is saved for unplaying purposes and function returns <code>true</code> ( playing a move was successfull ). Some trivial checks are performed afterwards it was found move is not a pass ( e.g. there is no stone on desired coordinates, it is not violating ko rule ). A complete record for unplaying is created and filled with the actual infromation.<p>
<div class="fragment"><pre class="fragment">      <a class="code" href="structUnplay__node.html">Unplay_node</a> * act_node = <span class="keyword">new</span> <a class="code" href="structUnplay__node.html">Unplay_node</a>(); <span class="comment">// creating new node in unplaying dynamic list </span>
      act_node-&gt;<a class="code" href="structUnplay__node.html#r0">next</a> = unplay_node_handle; <span class="comment">// adding a node to the beginning of existing dynamic list </span>
      unplay_node_handle = act_node;
      unplay_node_handle-&gt;<a class="code" href="structUnplay__node.html#r1">unplay_manager</a>.<a class="code" href="structUnplay__manager.html#r2">stone_to_unplay</a> = coordinates_; <span class="comment">// filling node with unplaying information </span>
      unplay_node_handle-&gt;unplay_manager.number_stones_de = number_stones_de;
      ... <span class="comment">// saving other datastructures: playable_man, pot_eyes_map, ko_manager, position_hash</span>
</pre></div><p>
If the move is a ko taking move ( checked by function Board_manager::takes_ko ), <a class="el" href="classBoard__manager.html#o3">Board_manager::ko_manager</a> is activated and filled with actual ko information ( where it takes place, which are retake coordinates, which player took the ko ). Now it comes time to add a stone into the block structure. First, new empty block is created and actual stone is added into it together with updating position hash key. <div class="fragment"><pre class="fragment">       <a class="code" href="classBlock.html">Block</a> * act_block_ = <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a1">create_new_block</a> ( stone_color_ ); <span class="comment">// creates an empty block</span>
       act_block_-&gt;<a class="code" href="classBlock.html#a4">add_stone</a> ( coordinates_ );  <span class="comment">// </span>
       board[coordinates_.<a class="code" href="classCoordinates.html#a3">get_co_row</a>()][coordinates_.<a class="code" href="classCoordinates.html#a4">get_co_column</a>()].set_present_block_pt( act_block_); <span class="comment">// sets a pointer from a board to the block</span>
       hash_board_manager.xor_with_position_hash ( coordinates_, stone_color_); <span class="comment">// updating position hash key </span>
</pre></div><p>
Now, more complicated part comes. At first cycle through the new block ( only one stone so far ) neighbouring coordinates is performed and liberties are added to the block as well as neigbour blocks of stones are saved for unplaying purposes ( see <a class="el" href="page_6.html#page_6__sec_4">Unplaying moves</a> ). Afterwards another cycle managing block structure updating is performed. It goes through new block ( actual ) neighbours again and merges actual block with neighbouring friendly blocks ( by calling <a class="el" href="classBoard__manager.html#a5">Board_manager::merge_blocks</a> ) into a single block of stones. This cycle also removes liberty from enemy neigbouring blocks and possibly performs function capturing this enemy block ( <a class="el" href="classBoard__manager.html#a2">Board_manager::capture_block</a> ) <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 4 ; i++ ) {
      ...
        <span class="comment">// getting pointer to adjacent block </span>
        adjacent_block_ =  board[adjacent_coordinates_[i].get_co_row()][adjacent_coordinates_[i].get_co_column()].get_present_block_pt() ; 
      ... 
        <span class="keywordflow">if</span>( adjacent_block_-&gt;stone_color == stone_color_) { <span class="comment">//adjacent block is a friendly one </span>
          adjacent_block_-&gt;remove_liberty( coordinates_ );
          merge_blocks(  act_block_  , adjacent_block_ ); <span class="comment">// merging adjacent and actual ( the one containing played stone ) into a single block</span>
        }
        <span class="keywordflow">else</span> { <span class="comment">// adjacent block is an enemy one </span>
          adjacent_block_-&gt;remove_liberty( coordinates_ ); 
          <span class="keywordflow">if</span> ( adjacent_block_-&gt;is_captured() ) { <span class="comment">// if last liberty was removed block will be captured </span>
            capture_block( adjacent_block_ );
          }
        ...
</pre></div><p>
Capturing a block ( <a class="el" href="classBoard__manager.html#a2">Board_manager::capture_block</a> ) is connected with updating ( stones from captured block are added ) the list of potential coordinates to play ( <a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a> ) and the list of potential eyes ( <a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a> - coordinates under captured stones become potential eyes ). Liberties are added to the neigbouring ( opponent's ) blocks and the position hash key is updated as well ( stones of the captured block are xored out ). At the end the block is removed by function <a class="el" href="classBoard__manager.html#a3">Board_manager::remove_block</a> ( updates pointers from <a class="el" href="classBoard__manager.html#r1">Board_manager::board</a> and items in <a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a> and destroys the block ). It is neccessary to take appropriate actions when "under the stones" treatment is switched off ( <code>-nus</code> parameter ). In that case when a defender block of at least 3 stones is captured ( expressed by variable <code>possible_under_the_stones</code> ), coordinates under the captured stones are not added to the <a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a> nor <a class="el" href="classBoard__manager.html#o0">Board_manager::pot_eyes_map</a>. Thus, the algorithm doesn't try to play under them. When no "under the stones" analysis is demanded, unsafe attacker's stones that captured this defender's block are excluded from the list of potential eyes ( they cannot be captured thus are not potential eyes ).<p>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> ( Coordinates_vector::iterator it = block_-&gt;stone_vector.begin() ; it &lt; block_-&gt;stone_vector.end() ; it++ )  {
        <span class="keywordflow">if</span> ( ( ! possible_under_the_stones ) || ( ! <a class="code" href="main_8h.html#a2">params_manager</a>.get_no_under_the_stones() ) ) {  <span class="comment">// data structures actualization</span>
          playable_map.insert ( make_pair ( (*it) , <a class="code" href="classPlayable__data.html">Playable_data</a>() ) );  <span class="comment">// now i can play there </span>
          pot_eyes_map.insert ( make_pair ( (*it) , 0 ) );  
        }
        hash_board_manager.xor_with_position_hash ( (*it), block_-&gt;stone_color); <span class="comment">// hash key actualization</span>
        ... <span class="comment">// adding liberties to adjacent blocks </span>
      }
      remove_block( block_);
</pre></div><p>
Finally in the process of playing a stone <a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a> and <a class="el" href="classBoard__manager.html#r2">Board_manager::playable_map</a> are updated according to the played stone. In the end it must be checked whether a played stone was not a suicide. If it was a suicide, stone is immediately unplayed ( thus keeping consistence of playing function ) and function returns <code>false</code> marking that move was illegal.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( act_block_-&gt;<a class="code" href="classBlock.html#a8">is_captured</a>() ) { <span class="comment">// stone must be prevented to commit a suicide</span>
      unplay_last_stone();
      <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// stone was not played </span>
    }
</pre></div><h2><a class="anchor" name="page_6__sec_4">
Unplaying moves</a></h2>
A single instance of <a class="el" href="structUnplay__manager.html">Unplay_manager</a> is capable of storing all information neccessary for an unplay of a single move. These instances are organized into a dynamic list in order to properly unplay all moves along the path to the actual position. Dynamic list thus consists of instances of <a class="el" href="structUnplay__node.html">Unplay_node</a> ( containig instance of <a class="el" href="structUnplay__manager.html">Unplay_manager</a> and pointer to next node ). Actually this dynamic list is backward organized ( new nodes are added to the beginning) thus nodes related to last moves are in the beginnning and those related to moves played earlier are in the end. Pointer Board_manager::Unplay_node_handle marks the beginning of this dynamic list. As shown above a new record ( instance of <a class="el" href="structUnplay__node.html">Unplay_node</a> ) is added to the dynamic structure in function <a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a>. Process of unplaying last played move ( another move cannot be unplayed ) is covered by function <a class="el" href="classBoard__manager.html#a16">Board_manager::unplay_last_stone</a>.<p>
Unplaying pass moves is handled at first. There are created special ( almost empty ) unplaying records for pass moves containing only information that pass was played and copy of <a class="el" href="classBoard__manager.html#o3">Board_manager::ko_manager</a> (this is neccessary because after pass it is possible to retake some ko which was forbidden before). If move is not pass, at first some data structures ( <code>playable_map</code> , <code>ko_manager</code>, <code>number_stones_de</code>, <code>pot_eyes_map</code>, <code>position_hash</code>) are just copied from the unplay record to the data structures in <a class="el" href="classBoard__manager.html">Board_manager</a>.<p>
<div class="fragment"><pre class="fragment">      playable_map = unplay_node_handle-&gt;unplay_manager.playable_map; 
      ko_manager = unplay_node_handle -&gt; unplay_manager.ko_manager;
      ...
</pre></div><p>
Now the block structure has to be restored. In the process of playing actual stone ( the one to unplay ) algorithm stored copies of blocks neighbouring to coordinate on which stone was played ( see <a class="el" href="page_6.html#page_6__sec_3">Playing a move</a> ). Actual block and block's neigbouring to coordinate on which stone was played are simply removed ( using function <a class="el" href="classBoard__manager.html#a3">Board_manager::remove_block</a> ). Now position on the board is updated by adding stored blocks into the block structure. This is done by the cycle through all stones in every of these blocks ( maximally four neighbouring blocks ) and setting pointers from adequate coordinates from <a class="el" href="classBoard__manager.html#r1">Board_manager::board</a> to the actual block, moreover <a class="el" href="classBoard__manager.html#o5">Board_manager::point_board</a> is updated.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i =0 ; i &lt; FOUR ; i++ ) {
      act_block_ =  unplay_node_handle-&gt;unplay_manager.neigbour_blocks[i];
      ... 
      <span class="keywordflow">for</span> ( Coordinates_vector::iterator it = act_block_ -&gt;stone_vector.begin() ; it &lt; act_block_ -&gt;<a class="code" href="classBlock.html#r6">stone_vector</a>.end() ; it++ ) { <span class="comment">//cycle </span>
        board[(*it).get_co_row()][(*it).get_co_column()].set_present_block_pt( act_block_ ); <span class="comment">// setting a pointer from Board_manager::board</span>

        <span class="keywordflow">if</span>  ( act_block_-&gt;<a class="code" href="classBlock.html#r1">stone_color</a> == sc_white )  <span class="comment">// updating Board_manager::point_board according to actual stone ( color , safe/unsafe )</span>
          point_board[(*it).get_co_row()][(*it).get_co_column()] = <a class="code" href="board_8h.html#a51a24">ps_de</a>; 
        <span class="keywordflow">else</span> { <span class="comment">// handling variants for ps_at and ps_uns_at </span>
          <span class="keywordflow">if</span> ( act_block_-&gt; safe ) 
          ...
    }
</pre></div><p>
Last obstacle is that some of neighbouring blocks might got captured by playing an actual stone ( in <a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a> ). In that case all stones of this block are cycled through and liberties representing these stones ( block was captured, therefore it provided liberties for adjacent blocks ) must be removed from all adjacent blocks. Finally handler to actual stone to unplay ( <a class="el" href="classBoard__manager.html#o6">Board_manager::unplay_node_handle</a> ) is forwarded to the next item in the dynamic list ( thus list gets ready for the next unplay ) and actual <a class="el" href="structUnplay__node.html">Unplay_node</a> is destroyed.<h2><a class="anchor" name="page_6__sec_5">
Static heuristics methods</a></h2>
<a class="el" href="classBoard__manager.html">Board_manager</a> contains set of methods supporting static heuristics neccessary for efficient tree search. They are quite similar and clearly benefit from chosen "block oriented" position representation. As an example I provide detailed description of <a class="el" href="classBoard__manager.html#a26">Board_manager::check_take_liberty</a>. This function is used to check whether played move captures, ataris or simply takes away liberty of opponent's unsafe block. These different actions are distinguished by demanded number of opponent's block's liberties : 1 for capture , 2 for atari , 0 stands for more than 2 and represents simply taking away the liberty. At first it is checked whether input <a class="el" href="classCoordinates.html">Coordinates</a> are valid ( not equal to <a class="el" href="classCoordinates.html">Coordinates</a> (-1,-1 ) ). Then in the cycle neighbouring coordinates of coordinate in check are retrieved and so are the blocks of stones covering them. After neccessary trivial checks ( negihbouring coordinates are on the board, neighbouring block is present ) a simple test whether neighbouring block matches the conditions is done It matches the conditions if it is an unsafe opponent's block with an appropriate number of liberties.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; FOUR ; i++ ) {
      adjacent_coordinates_ = get_adjacent_coordinates ( coordinates_ , <a class="code" href="board_8h.html#a53">Direction</a> ( i ) ); <span class="comment">// neighbouring coordinates</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classCoordinates.html">Coordinates</a> ( -1, -1 ) == adjacent_coordinates_ ) <span class="comment">// out of board</span>
        <span class="keywordflow">continue</span>;
      adjacent_block_ = board[adjacent_coordinates_.get_co_row()][adjacent_coordinates_.get_co_column()].get_present_block_pt(); <span class="comment">//neighbouring block</span>
      <span class="keywordflow">if</span> ( adjacent_block_ != NULL &amp;&amp; adjacent_block_-&gt; stone_color != stone_color_ &amp;&amp; ! adjacent_block_-&gt;safe &amp;&amp; 
          ( adjacent_block_-&gt;liberty_count == liberty_num_ || liberty_num_ == 0 ) )  {
        ... <span class="comment">// here function returns pointer to block whose liberty is taken </span>
        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// test was successfull</span>
      }
    }
</pre></div><p>
All static heuristic methods are declared within <a class="el" href="classBoard__manager.html">Board_manager</a> and begin with a keyword "check". <hr size="1"><address style="align: right;"><small>Generated on Wed May 24 10:11:22 2006 for TGA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
