<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TGA: Tree search</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="page_3">Tree search</a></h1>Tree search is the most interesting section of the whole program. It is mainly implemented in <code><a class="el" href="t__search_8cc.html">t_search.cc</a></code> and <code><a class="el" href="t__search_8h.html">t_search.h</a></code>, search itself is managed by class <code><a class="el" href="classT__searcher.html">T_searcher</a></code> ( especially functions <code><a class="el" href="classT__searcher.html#a0">T_searcher::search</a></code> and <code><a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a></code> which creates an indirect recursion relationship ). Other classes defined in <code><a class="el" href="t__search_8h.html">t_search.h</a></code> have supporting tasks :<ul>
<li><code><a class="el" href="classSgf__printer.html">Sgf_printer</a></code> takes care of creating sgf output of the problem.</li><li><code><a class="el" href="classHash__table__item.html">Hash_table_item</a></code> represents item stored in transposition tables or for repetition recognition purposes.</li><li><code><a class="el" href="classHash__table__manager.html">Hash_table_manager</a></code> conducts transposition tables.</li><li><code><a class="el" href="classHash__repset__manager.html">Hash_repset_manager</a></code> guards possible repetitions.</li></ul>
<h2><a class="anchor" name="page_3__sec_1">
Tree search implementation description</a></h2>
Tree search is ( as mentioned above ) done in two functions ( <code><a class="el" href="classT__searcher.html#a0">T_searcher::search</a></code> and <code><a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a></code> ). Let's see how is the tree search implemented ( I will describe most important things happening in a single node ). After some neccessary initializations it is checked ( only if option <code>-ntt</code> is not switched on ) whether actual position doesn't match some position stored in transposition tables. In case that iddfs is active it is important to include transposition table cutoff ( for <code>gs_unknown</code> status ) even when status stored in the tables is <code>gsa_depth_uncertain</code> ( if cutoff would not be performed same search as in the saved position would be done and <code>gs_unknown</code> status would be gained again ).<p>
<div class="fragment"><pre class="fragment"><a class="code" href="eyes_8h.html#a11">Group_status</a> act_status_ = hash_table_manager.get_item_status( 
  <a class="code" href="classHash__table__item.html">Hash_table_item</a>( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o2">hash_board_manager</a>.<a class="code" href="classHash__board__manager.html#a2">get_position_hash</a>(),
    stone_color_to_move_, <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o3">ko_manager</a>.<a class="code" href="classKo__manager.html#a2">get_retake_coordinates</a>(),
    alfa, beta)); <span class="comment">// retrieveng status from transposition tables </span>
        
 ... <span class="comment">// adjusting alpha and beta according to saved values                                                                  </span>
  
 <span class="comment">// iddfs, this node was already searched ( and gsa_depth_uncertain status was obtained ) </span>
<span class="keywordflow">if</span> ( same_depth_limit &amp;&amp; act_accuracy_ == <a class="code" href="t__search_8h.html#a13a7">gsa_depth_uncertain</a> 
     &amp;&amp; <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a16">get_iddfs</a>())
  <span class="keywordflow">return</span> <a class="code" href="structSearch__result.html">Search_result</a>( <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>,<a class="code" href="t__search_8h.html#a13a7">gsa_depth_uncertain</a>, act_tree_size_); 

<span class="comment">// act_status_ is set from t_tables if stored alpha == stored beta  </span>
<span class="keywordflow">if</span> ( act_status_ != <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>) { 
  <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#o0">buff</a> &lt;&lt; <span class="stringliteral">"Transposition table cutoff for status: "</span> &lt;&lt; act_status_ &lt;&lt; endl;
  ...
  <span class="keywordflow">return</span> act_status_; <span class="comment">// control is returned to father</span>
 }
</pre></div><p>
If this test is negative ( position hash key was not found in <code><a class="el" href="classHash__table__manager.html#r1">Hash_table_manager::hash_table</a></code> ), static life and death analyses together with simple capture recognition cutoff ( too little defender's stones cannot create a living group ) is performed: <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (( stone_color_to_move_ == sc_black &amp;&amp; 
      <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o4">number_stones_de</a> &lt; TOO_LITTLE_TO_LIVE) || <span class="comment">// TOO_LITTLE_TO_LIVE is 4</span>
    ( stone_color_to_move_ == sc_white &amp;&amp; 
      <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o4">number_stones_de</a> &lt; TOO_LITTLE_TO_LIVE -1)) 
  act_status_ = <a class="code" href="eyes_8h.html#a11a1">gs_dead</a> ; <span class="comment">//too little stones to live  </span>
<span class="keywordflow">else</span> 
  act_status_ = <a class="code" href="eyes_8h.html#a0">eye_manager</a>.is_alive( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a17">get_point_board</a>(),
    <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a19">get_pot_eyes_map_pt</a>()); <span class="comment">// static life and death analysis</span>
</pre></div><p>
If this analyses doesn't succeed in recognizing the group neither alive ( <code> act_status_ == gs_alive </code> ) nor dead ( <code> act_status_ == gs_dead </code> ), then status of actual node will be decided from statuses of his sons. At first different static heuristics are applied. Each heuristic might change moves priority by specified margin. The lesser the priority the more important move becomes ( and thus more probable is that it will be tried first ). Effects of different heuristics might be cumulated ( some move might be recognized as very good by more heuristics ). Moves are sorted ( according to their priority decided by heuristics ) in order to make pruning techniques ( especially alpha beta ) more effective. Self atari pruning technique is applied as well ( larger defender's blocks are not allowed to self atari ). Application of some heuristics is shown below:<p>
<div class="fragment"><pre class="fragment"><span class="comment">//checking whether a played move is a self atari</span>
<span class="keywordflow">if</span> (( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a21">check_self_atari</a>( stone_color_to_move_, last_item.first, 
                                      &amp;stone_in_atari_num))) {
  <span class="keywordflow">if</span> ( stone_color_to_move_ == sc_black &amp;&amp; stone_in_atari_num &lt;= 2 ) 
    last_item.second.increase_act_heuristic_pp( 5); <span class="comment">// this selfatari is mediocry demoted</span>
  <span class="keywordflow">else</span> 
    last_item.second.increase_act_heuristic_pp( 10); <span class="comment">// this move is very much demoted </span>
  <span class="keywordflow">if</span> ( stone_in_atari_num &gt;= 3 &amp;&amp; stone_color_to_move_ == sc_white ) {
    last_item.second.set_act_main_pp ( <a class="code" href="board_8h.html#a52a33">pp_none</a> ); <span class="comment">// this prevents move to be played </span>
    <span class="keywordflow">continue</span>; <span class="comment">// no search when atari on more than 2 defender's stones </span>

<span class="comment">//capture heuristic</span>
<span class="keywordflow">if</span> (( node_type_ == nt_max ) &amp;&amp; 
    ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a24">check_capture</a>( stone_color_to_move_, last_item.first))) 
  last_item.second.increase_act_heuristic_pp( -5); <span class="comment">// this move is promoted</span>
  ... <span class="comment">// Other heuristics. The lesser the evaluation of the move the more it is promoted</span>
</pre></div><p>
Pass moves are included in the list of moves as well. Generally moves are ordered in the following way ( this is a primar ordering, secondary ordering is represented by heuristic results ):<ul>
<li>At first "ordinary" moves" ( not pass, not ko taking moves ) sorted by heuristic evaluation.</li><li>A pass move.</li><li>At last ko taking moves ( there is a possibility of starting the ko for life of the group ).</li></ul>
<p>
After the moves are sorted (according to their priority), they are stored in <code>Playable_vector</code>. Then the program goes through this vector of possible moves and tries to play them out. The line of algorithm slightly differs according to the type of the node ( <code>nt_min</code> , <code>nt_max</code> ). Howewer the principle is the same ( I will give code examples for defender's node since that one is a bit more complicated ):<ul>
<li>At first some checks related to playing a pass are performed. Pass is always involved in the list of the moves to be played, however whether it is really played is decided right before playing it). Pass is played ( this is expressed by variable <code>play_pass_allowed</code> ) only in following cases :<ul>
<li>Ko taking move ( potentially making group status ko ) is present. Then pass is neccessary to decide whether the ko taking move is relevant to life and death of the group ( pass simulates situation when opponent ignores a ko threat and tries to yield from the ko ).</li><li>In defender's node, none of the searched sons didn't reach status <code>gs_alive</code> and there are maximally 4 legal moves ( then pass is looking for possibility of seki ). <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( stone_color_to_move_ == sc_white ) { 
  <span class="comment">//next condition is neccessary for seki status </span>
  <span class="keywordflow">if</span> ( act_status_ != <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>  &amp;&amp; legal_moves_num &lt;= 4 )
    play_pass_allowed = <span class="keyword">true</span>; } <span class="comment">// pass is allowed</span>
</pre></div></li></ul>
</li></ul>
<p>
<ul>
<li>In attacker's node, at least one son have reached <code>ko</code> status and none of sons have reached <code>dead</code> status. Then ( if there are maximally 4 legal moves - pruning technique ) pass move is tried in order to reveal potential <code>dead</code> group status because of "bent four in the corner".</li></ul>
<p>
<ul>
<li>Afterwards, the actual move is played ( <code><a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a></code> ). When it is illegal ( <code><a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a></code> returns <code>false</code> ) next move is tried. <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( ! <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a4">play_a_stone</a> ( sc_white ,(*it).first)) 
  <span class="keywordflow">continue</span>; 
<span class="keywordflow">else</span>
  legal_moves_num++;
</pre></div></li></ul>
<p>
<ul>
<li>Son of the actual node is searched recursively by calling <code><a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a></code> function ( however recursion is indirect since method <code><a class="el" href="classT__searcher.html#a0">T_searcher::search</a></code> is called from <code><a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a></code> ). In <code><a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a></code> there is also handled part of the sgf output for the son ( e.g. outputting move's coordinates, potential output pruning ). Moreover repetitions are tested and possible repetition cutoff is done. Reason for this indirect recursion is that actions related with searching the son is in defender's and attacker's pretty identical ( the only practical difference is the color of the played stone printed to the sgf output). <div class="fragment"><pre class="fragment">son_result = search_son( (*it).first, nt_min, level, alfa, beta, play_ko_for_life);
</pre></div></li></ul>
<p>
<ul>
<li>Possible special handling for ko/double ko is performed. This is a very interesting ( and also was quite difficult to programm ) section of the algorithm. As mentioned above, when there is a ko taking move it is being searched as the last one ( because this raises probability of cutoff before searching the ko taking move). After searching this move, it's status might be transformed ( see below ) to <code>gs_ko</code> ( transformation takes place when variable <code>play_ko_for_life</code> is <code>true</code>). When value of <code>play_ko_for_life</code> is <code>false</code> ( in the moment when son where ko was taken should be searched ) then the ko is not relevant to the result and thus outcoming status of the son is not transformed ( to the <code>gs_ko</code> status ). Varibale <code>play_ko_for_life</code> is set ( actually this is done before the son is searched ) as follows ( in defender's node): <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( play_ko 
  &amp;&amp; after_pass_group_status != <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>  <span class="comment">//unconditionaly alive</span>
  &amp;&amp; after_pass_group_status &lt;= <a class="code" href="eyes_8h.html#a11a3">gs_ko</a>    <span class="comment">//after pass black can get at least ko</span>
  &amp;&amp; ( act_status_ !=  <a class="code" href="eyes_8h.html#a11a4">gs_alive</a> ) ) <span class="comment">//defender cannot live without ko </span>
    play_ko_for_life = <span class="keyword">true</span>;
</pre></div> Here even when <code>act_status_</code> is <code>gs_ko</code> it is still possible to get unconditional live through double ko ( therefore taking the ko is tried ). In attacker's node, conditions ( last three in the "if" statement ) for stating <code>play_ko_for_life</code> are almost symetrical with the exception that <code>gs_ko</code> value of <code>act_status_</code> causes cutoff ( if attacker can get the ko there is no reason to try taking the ko because he cannot get a better result ).</li></ul>
<p>
<ul>
<li>After searching the ko taking move, son's status ( <code>son_result.group_status</code> ) is transformed as follows ( before passing it to section of comparing against <code>actual_status_:</code> see <a class="el" href="page_3.html#node_comparing">comparing</a>): When <code>play_ko_for_life</code> is <code>true</code> ( all preliminary conditions for <code>gs_ko</code> status are fulfilled ) then value <code>gs_alive</code> ( <code>gs_dead</code> in attacker's node ) of son's status is transformed to <code>gs_ko</code>. This operation says: when defender can live after taking the ko ( attacker in son's node is not allowed to recapture the ko, but in his turn pass move "simulating" possible defender's ignoration of ko threat is naturally involved ) then he is alive in ko. And symetrically for the attacker taking the ko. Moreover in defender's node double ko test is performed : <div class="fragment"><pre class="fragment"><span class="comment">// double ko handling, ko was taken this turn - possible double ko check </span>
<span class="keywordflow">if</span> (( ! <a class="code" href="main_8h.html#a2">params_manager</a>.get_no_ko_handling() ) &amp;&amp; 
    (play_ko_for_life &amp;&amp; son_result.group_status == <a class="code" href="eyes_8h.html#a11a3">gs_ko</a> )) { 
  <span class="keywordflow">if</span> ( possible_double_ko ) { <span class="comment">// two independent ko's which white can start -&gt; life</span>
    <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#o0">buff</a> &lt;&lt;  <span class="stringliteral">"Alive in double ko"</span> ; <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#a5">print_comment</a>(<span class="keyword">true</span>);
    son_result.group_status = <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>;
  }
  <span class="keywordflow">else</span> 
    possible_double_ko = <span class="keyword">true</span>;
    <span class="keywordflow">if</span> ( last_move_ko ) { 
      <span class="comment">// last move started ko for life and defender found another ko =&gt; double ko</span>
      son_result.group_status = <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>;
      <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#o0">buff</a> &lt;&lt;  <span class="stringliteral">"Alive in double ko"</span> ; <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#a5">print_comment</a>(<span class="keyword">true</span>);
    }
}
</pre></div></li></ul>
<p>
<a class="anchor" name="node_comparing"></a><ul>
<li>Gathered status of the son is compared to <code>actual_status_</code> ( the best fitting status so far ) and possible alpha beta cutoff is performed. In this part it is neccessary to take into account accuracy of the actual group status as well ( expresed by <code>act_accuracy_</code> of <code>Group_status_accuracy</code> type ). Value <code>gsa_certain</code> accuracy expresses that status represents best play of both players. On the other hand value <code>gsa_alfa_beta_uncertain</code> means that since alpha beta cutoff was performed retrieved group status might be incorrect, however in relation to the previous searches and previously set <code>alpha</code> and <code>beta</code> it is satisfying. It is clear that <code>gsa_certain</code> accuracy is prefered to <code>gsa_alpha_beta_uncertain</code>. Thus, algorithm tries to propagate upwards the tree group statuses with <code>gsa_certain</code> accuracy. Therefore, if in one node there are two sons with same group status ( usually this is <code>gs_ko</code> ) and with different accuracies ( <code>gsa_certain</code> and <code>gsa_alfa_beta_uncertain</code> ) than the one with <code>gsa_certain</code> surpasses the second one. As a side note: it is clear that group statuses with uncertain accuracy ( <code>gsa_alfa_beta_uncertain</code>, <code>gsa_depth_uncertain</code> ) are not included in the pruned sgf output ( <code>-ps</code> is switched on ), because they might provide confusing information ( human doesn't take into account alpha beta values when browsing search results). This natural part of minimax algorithm with alpha beta pruning is in defender's node ( attacker's node is symmetrical ) programmed as follows: <div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( son_result_.group_status != <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a> &amp;&amp; 
     act_status_ &lt;= son_result_.group_status || act_status_ == <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>)) {
  <span class="keywordflow">if</span> ( act_status_ == son_result_.group_status ) {
    <span class="keywordflow">if</span> ( act_accuracy_ != <a class="code" href="t__search_8h.html#a13a6">gsa_certain</a> )  <span class="comment">//better accuracy ( certain )</span>
      act_accuracy_ = son_result_.group_status_accuracy; 
  }
  <span class="keywordflow">else</span>  <span class="comment">// act_status_ &lt; son_result_.group_status, accuracy of better solution</span>
    act_accuracy_ = son_result_.group_status_accuracy; 

  act_status_ = son_result_.group_status; 
  <span class="keywordflow">if</span> ( ab_pruning &amp;&amp; alfa &lt; act_status_)  <span class="comment">// alpha update </span>
    alfa = act_status_;
  }

  <span class="comment">// alpha beta cutoff</span>
  <span class="keywordflow">if</span> ( ab_pruning &amp;&amp; ( act_status_ &gt;= beta ) ) { <span class="comment">//pruning</span>
    ...
    <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a16">unplay_last_stone</a>(); <span class="comment">//unplays son's move </span>
    ... <span class="comment">// storing actual position to transposition table  </span>
    <span class="keywordflow">return</span> act_status_;
  }
</pre></div></li></ul>
<p>
<ul>
<li>Actual move is unplayed and another one is tried. This is done by simply calling function <code><a class="el" href="classBoard__manager.html#a16">Board_manager::unplay_last_stone()</a></code> and continuing to cycle through the possible moves.</li><li>Returning status of the actual node. Two things must not be forgotten before returning a status ( result of the node ) of the group in the actual node:<ul>
<li>Keeping consistency of the position. This is done by calling function <code><a class="el" href="classBoard__manager.html#a16">Board_manager::unplay_last_stone()</a></code> in cases when status of the node is returned before all son's are resolved ( due to some pruning, usually alpha beta ).</li><li>Storing actual position to transposition tables ( only when option <code>-ntt</code> is switched on ) with appropriately set input and output alpha beta values together with accuracy of actual result and other information. This is done by following source code: <div class="fragment"><pre class="fragment">hash_table_manager.store_item ( 
  <a class="code" href="classHash__table__item.html">Hash_table_item</a> ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o2">hash_board_manager</a>.<a class="code" href="classHash__board__manager.html#a2">get_position_hash</a>(),
                    stone_color_to_move_,
                    <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o3">ko_manager</a>.<a class="code" href="classKo__manager.html#a2">get_retake_coordinates</a>(),
                    in_alfa, in_beta, act_accuracy_, act_status, act_status_)); 
</pre></div></li></ul>
</li></ul>
<h2><a class="anchor" name="page__1_section_2">
Transposition tables implementation</a></h2>
Very close to the tree search is the implementation of transposition tables. It is done in <code><a class="el" href="t__search_8cc.html">t_search.cc</a></code> and <code><a class="el" href="t__search_8h.html">t_search.h</a></code>. Transposition tables are handled by class <code><a class="el" href="classHash__table__manager.html">Hash_table_manager</a></code> which contains a table representing saved positions and provides functions to perform operations upon the table. Transposition table itself ( <code><a class="el" href="classHash__table__manager.html#r1">Hash_table_manager::hash_table</a></code> ) is implemented as an array of pointers to the <code><a class="el" href="classHash__table__item.html">Hash_table_item</a></code> ( representing one saved position ). Since today's computers don't struggle with memory shortage as it was usual in the past I decided for fixed-size table with over two million entries ( therefore an empty table takes around 8MB RAM on 32 bit architecture ). During the search process table grows as there are new positions being stored in. Size ( number of items ) of the hash table doesn't change in the process of solving Go problem. When a table becomes rather full ( number of stored position equals 1/2 of the sum of pointers from <code>Hash_board_manager::hash_table</code> ) then saving mode is toggled on and new positions are stored on the place of old ones. Hashing function is ordinary modulo on the higher bits of position's hash key ( representing the position ). Reason for this is that random generators ( hash key's are made up of random numbers : see <a class="el" href="page_6.html">Position representation</a> ) are "more random" in the higher bits. For collision solving typical method of separate chaining is used : each item in the table is a head of a chain containing items with same modulo ( result of hashing function ) of hash key. New items are stored to the end of the chain. When searching for a particular item whole chain ( in the worst case ) must be searched. The key operations upon the table are:<p>
<ul>
<li>Inserting new item into the table ( <code><a class="el" href="classHash__table__manager.html#a5">Hash_table_manager::store_item</a></code> ) At first, position's hash key must be normalized by the color of the player to move. This is done according to Zobrist method in function <code><a class="el" href="classHash__table__manager.html#a4">Hash_table_manager::get_normalized_hash_key()</a></code>. Then hashing function is applied on the normalized hash key : <div class="fragment"><pre class="fragment"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pos = ( item.hash_key &gt;&gt; shift_num ) % hash_table_size;
</pre></div> If saving mod is toggled on ( there are too many positions in the hash table ) then actual position is stored to the first place in the appropriate chain ( replacing some previous position ). Usually ( not in saving mod ) algorithm goes through chain and tries to update some already stored item ( actual item is a "new version" of a position stored previously ) with function <code>hash_board_manager::actualize_item()</code>. When no actualization is done new position is simply stored to the end of the chain. <div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> ( act_row = 1 ; act_item-&gt;next != NULL ; act_row++ ) {
  <span class="keywordflow">if</span> (  actualize_item (  act_item , item ) ) 
    <span class="keywordflow">return</span>;    <span class="comment">// successfull actualization</span>
    act_item = act_item-&gt;next; <span class="comment">// next item in the chain</span>
  }
  act_item-&gt;next = <span class="keyword">new</span> <a class="code" href="classHash__table__item.html">Hash_table_item</a> ( item); <span class="comment">// saving actual position to the end</span>
</pre></div></li></ul>
<p>
<ul>
<li>Retrieving information from the table ( <code><a class="el" href="classHash__table__manager.html#a6">Hash_table_manager::get_item_status</a></code> ) As in the previous method position's hash key is normalized and position in the table ( <code>pos</code> ) is retrieved. Then cycle goes through chain of the stored items until it reaches the end or it founds corresponding item ( this is decided by applying function <code><a class="el" href="t__search_8cc.html#a0">corresponds()</a></code> to both actual and stored item ). Function <code>coorresponds()</code> compares whole ( not shortened by modulo ) hash keys and ko retake coordinates ( this is important : position is determined by it's hash key and position of potential ko ). Moreover it compares input <code>alpha</code> and <code>beta</code> values of both stored position and the actual position ( in the process of tree search ) and takes into account saved position accuracy to decide whether saved output <code>alpha</code> and <code>beta</code> values might be provided for actual position. <div class="fragment"><pre class="fragment"><span class="comment">//certain status provides more general condition to apply transposition table cutoff</span>
<span class="keywordflow">if</span> ( saved_.accuracy == <a class="code" href="t__search_8h.html#a13a6">gsa_certain</a> ) { 
  <span class="keywordflow">if</span> (!((( saved_.node_type == nt_max ) &amp;&amp; (( new_.beta &lt;= saved_.beta ) 
      || ( saved_.new_alfa &lt; saved_.beta )))  || 
        (( saved_.node_type == nt_min ) &amp;&amp; (( saved_.alfa &lt;= new_.alfa ) 
      || ( saved_.alfa &lt; saved_.new_beta ))))) 
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
} 
<span class="keywordflow">else</span> <span class="comment">// more resolute conditions, because group status is not certain </span>
  <span class="keywordflow">if</span> (!(( new_.beta &lt;= saved_.beta) &amp;&amp; ( saved_.alfa &lt;= new_.alfa))) 
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
</pre></div></li></ul>
<p>
Tree search is the most interesting section of the whole program. It is mainly implemented in <code><a class="el" href="t__search_8cc.html">t_search.cc</a></code> and <code><a class="el" href="t__search_8h.html">t_search.h</a></code>, search itself is managed by class <a class="el" href="classT__searcher.html">T_searcher</a> ( especially functions <a class="el" href="classT__searcher.html#a0">T_searcher::search</a> and <a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a> which creates an indirect recursion relationship ). Other classes defined in <code><a class="el" href="t__search_8h.html">t_search.h</a></code> have supporting tasks :<ul>
<li><a class="el" href="classSgf__printer.html">Sgf_printer</a> takes care of creating sgf output of the problem.</li><li><a class="el" href="classHash__table__item.html">Hash_table_item</a> represents item stored in transposition tables or for repetition recognition purposes.</li><li><a class="el" href="classHash__table__manager.html">Hash_table_manager</a> conducts transposition tables.</li><li><a class="el" href="classHash__repset__manager.html">Hash_repset_manager</a> guards possible repetitions.</li></ul>
<h2><a class="anchor" name="page_3__sec_1">
Tree search implementation description</a></h2>
Tree search is ( as mentioned above ) done in two functions ( <a class="el" href="classT__searcher.html#a0">T_searcher::search</a> and <a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a> ). Let's see how is tree search implemented ( I will describe most important things happening in one single node ) . After some neccessary initializations it is checked ( only when option <code>-tt</code> is switched on ) whether actual position doesn't match some position stored in transposition tables. In case that iddfs is active it is important to include transposition table cutoff ( for <code>gs_unknown</code> status ) even when status stored in the tables is <code>gsa_depth_uncertain</code> ( because when cutoff would not be performed same search as in saved position would be done and <code>gs_unknown</code> status would be gained again ).<p>
<div class="fragment"><pre class="fragment"> AHOJ
<a class="code" href="eyes_8h.html#a11">Group_status</a> act_status_ = hash_table_manager.get_item_status( 
 <a class="code" href="classHash__table__item.html">Hash_table_item</a>(<a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o2">hash_board_manager</a>.<a class="code" href="classHash__board__manager.html#a2">get_position_hash</a>(),stone_color_to_move_
  ,<a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o3">ko_manager</a>.<a class="code" href="classKo__manager.html#a2">get_retake_coordinates</a>(),alfa,beta));
        
 ... <span class="comment">// adjusting alfa and beta according to saved values                                                                 </span>
  
 <span class="comment">// in iddfs even gsa_depth_uncertain status is accepted</span>
<span class="keywordflow">if</span> (same_depth_limit &amp;&amp; act_accuracy_ == <a class="code" href="t__search_8h.html#a13a7">gsa_depth_uncertain</a> &amp;&amp; <a class="code" href="main_8h.html#a2">params_manager</a>.<a class="code" href="classParams__manager.html#a16">get_iddfs</a>()) 
  <span class="keywordflow">return</span> <a class="code" href="structSearch__result.html">Search_result</a>(<a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>,<a class="code" href="t__search_8h.html#a13a7">gsa_depth_uncertain</a>,act_tree_size_); 

 <span class="comment">// act_status_ is set from t_tables if stored alfa == stored beta  </span>
 <span class="keywordflow">if</span> (act_status_ != <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>) { 
   <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#o0">buff</a> &lt;&lt; <span class="stringliteral">"Transposition table cutoff for status : "</span> &lt;&lt; act_status_ &lt;&lt; endl;
   ...
   <span class="keywordflow">return</span> act_status_;
 }
</pre></div> When this test is negative ( position hash key was not found in <a class="el" href="classHash__table__manager.html#r1">Hash_table_manager::hash_table</a> ), static life &amp; death analyses together with simple capture recognition cutoff ( too little defender's stones cannot create a living group ) is performed: <div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> ((stone_color_to_move_ == sc_black &amp;&amp; 
     <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o4">number_stones_de</a> &lt; TOO_LITTLE_TO_LIVE) || <span class="comment">// TOO_LITTLE_TO_LIVE is set to 4   </span>
     (stone_color_to_move_ == sc_white &amp;&amp; 
     <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o4">number_stones_de</a> &lt; TOO_LITTLE_TO_LIVE -1)) <span class="comment">// too little stones to live </span>
   act_status_ = <a class="code" href="eyes_8h.html#a11a1">gs_dead</a> ;
 <span class="keywordflow">else</span> 
   act_status_ = <a class="code" href="eyes_8h.html#a0">eye_manager</a>.is_alive(<a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a17">get_point_board</a>(), 
                 <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a19">get_pot_eyes_map_pt</a>());
</pre></div><p>
When this analyses doesn't succeed in recognizing the group neither alive ( <code> act_status_ == gs_alive </code> ) nor dead ( <code> act_status_ == gs_dead </code> ), then status of actual node will be decided from statuses of his sons. At first different static heuristics are applied. Each heuristic might change moves priority by specified margin. The lesser the priority the more important move becomes ( and thus more probable is it will be tried first ). Effects of different heuristics might be cumulated ( some move might be recognized as very good by more heuristics ). Moves are sorted ( according to their priority decided by heuristics ) in order to make pruning techniques ( especially alfa beta ) more effective. Self atari pruning technique is applied as well ( larger defender's blocks are not allowed to self atari ). Application of some heuristics is shown below:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> ((<a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a21">check_self_atari</a>(stone_color_to_move_,last_item.first,&amp;stone_in_atari_num))) {
   <span class="keywordflow">if</span> ( stone_color_to_move_ == sc_black &amp;&amp; stone_in_atari_num &lt;= 2 ) 
    last_item.second.increase_act_heuristic_pp( 5 ); <span class="comment">// attackers selfatari on less than two stons is mediocry demoted</span>
  <span class="keywordflow">else</span> 
    last_item.second.increase_act_heuristic_pp( 10 ); <span class="comment">// this move is VERY much demoted </span>
      <span class="keywordflow">if</span> ( stone_in_atari_num &gt;= 3 &amp;&amp; stone_color_to_move_ == sc_white ) {
    last_item.second.set_act_main_pp ( pp_none ); <span class="comment">// no search when atari on more than 2 defender's stones </span>
    <span class="keywordflow">continue</span>;

  <span class="comment">//capture heuristic</span>
  <span class="keywordflow">if</span> ( (node_type_ == nt_max ) &amp;&amp; ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a24">check_capture</a>( stone_color_to_move_ , last_item.first ) ) ) 
  last_item.second.increase_act_heuristic_pp( -5 ); <span class="comment">// the lesser the number the more is move promoted</span>
    
  ... <span class="comment">// other heuristics </span>
</pre></div><p>
Pass moves are included in the list of moves as well. Generally moves are ordered in following way ( this is a primar ordering, secondary ordering is represented by heuristic results ):<ul>
<li>At first "ordinary" moves ( not pass, not ko taking moves ) sorted by heuristic evaluation.</li><li>pass move.</li><li>At last ko taking moves ( there is a possibility of starting ko for life of the group ).</li></ul>
<p>
After the moves are sorted( according to their priority), they are stored in Playable_vector. Then the program goes through this vector of possible moves and tries to play them out. The line of algorithm slightly differs according to the type of node ( <code>nt_min</code> , <code>nt_max</code> ). Howewer the principle is the same ( I will give code examples for defender's node since that one is a bit more complicated ):<ul>
<li>At first some checks related to playing a pass are performed. Pass is always involved in the list of the moves to be played, however whether it is really played is decided right before playing it). Pass is played ( this is expressed by variable <code>play_pass_allowed</code> ) only in following cases :<ul>
<li>Ko taking move ( potentially making group status ko ) is present. Then pass is neccessary to decide whether the ko taking move is relevant to life &amp; death of the group ( pass simulates situation when opponent ignores a ko threat and tries to yield from the ko ).</li><li>In defender's node, none of the searched sons didn't reach status <code>gs_alive</code> and there are maximally 4 legal moves ( then pass is looking for possibility of seki ). <div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> ( stone_color_to_move_ == sc_white ) { 
        <span class="keywordflow">if</span> ( act_status_ != <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>  &amp;&amp; legal_moves_num &lt;= 4 ) <span class="comment">//neccessary condition to play pass</span>
          play_pass_allowed = <span class="keyword">true</span>; } <span class="comment">// pass is allowed</span>
</pre></div></li><li>In attacker's node, at least one son have reached <code>ko</code> status and none of sons have reached <code>dead</code> status. Then ( if there are maximally 4 legal moves - pruning technique ) pass move is tried in order to reveal potential <code>dead</code> group status because of "bent four in the corner".</li></ul>
</li></ul>
<p>
<ul>
<li>Afterwards, the actual move is played ( <a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a> ). When it is illegal ( <a class="el" href="classBoard__manager.html#a4">Board_manager::play_a_stone</a> returns <code>false</code> ) next move is tried <div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> ( ! <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a4">play_a_stone</a> ( sc_white ,(*it).first ) ) 
        <span class="keywordflow">continue</span>; 
      <span class="keywordflow">else</span>
        legal_moves_num++;
</pre></div></li></ul>
<p>
<ul>
<li>Son of the actual node is searched recursively by calling <a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a> function ( however recursion is indirect since method <a class="el" href="classT__searcher.html#a0">T_searcher::search</a> is called from <a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a> ). In <a class="el" href="classT__searcher.html#a11">T_searcher::search_son</a> there is also handled part of the sgf output for the son ( e.g. outputting move's coordinates, potential output pruning ) Moreover repetitions are tested and possible repetition cutoff is done. Reason for this indirect recursion is that actions related with searching the son is in defender's and attacker's pretty identical ( the only practical difference is the color of the played stone printed to the sgf output).</li></ul>
<p>
<div class="fragment"><pre class="fragment">    son_result = search_son ( (*it).first , nt_min , level , alfa , beta , play_ko_for_life);  
</pre></div><ul>
<li>Possible special handling for ko / double ko is performed. This is a very interesting ( and also was quite difficult to programm ) section of the algorithm. As mentioned above, when there is a ko taking move it is being searched as the last one ( because this raises probability of cutoff before searching the ko taking move) . After searching this move, it's status might be transformed ( see below ) to <code>gs_ko</code> ( transformation takes place when variable <code>play_ko_for_life</code> is true). When value of <code>play_ko_for_life</code> is <code>false</code> ( in the moment when son where ko was taken should be searched ) then ko is not relevant to the result and thus outcoming status of the son is not transformed ( to the <code>gs_ko</code> status ) . Varibale <code>play_ko_for_life</code> is set ( actually this is done before the son is searched ) as follows ( in defender's node): <div class="fragment"><pre class="fragment">        <span class="keywordflow">if</span> ( play_ko 
                &amp;&amp; after_pass_group_status != <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a>  <span class="comment">// if gs_unknown -&gt; no determined status was gained after pass -&gt; unc. alive</span>
                &amp;&amp; after_pass_group_status &lt;= <a class="code" href="eyes_8h.html#a11a3">gs_ko</a>    <span class="comment">//when white ignore black threat he might get at least ko, otherwise unc.alive  </span>
                &amp;&amp; ( act_status_ !=  <a class="code" href="eyes_8h.html#a11a4">gs_alive</a> ) ) <span class="comment">//defender cannot live without ko </span>
        play_ko_for_life = <span class="keyword">true</span>;
</pre></div> Here even when <code>act_status_</code> is <code>gs_ko</code> it is still possible to get unconditional live through double ko ( therefore taking the ko is tried ). In attacker's node conditions ( last three in the if statement ) for stating <code>play_ko_for_life</code> are almost symetrical with the exception that <code>gs_ko</code> value of <code>act_status_</code> causes cutoff ( this is clear ... when attacker can get a ko there is no reason to try taking ko because he cannot get a better result ).</li></ul>
<p>
After searching the ko taking move, son's status ( <code>son_result.group_status</code> ) is transformed as follows ( before passing it to section of comparing against <code>actual_status_:</code> see <a class="el" href="page_3.html#node_comparing">comparing</a>): When <code>play_ko_for_life</code> is <code>true</code> ( all preliminary conditions for <code>gs_ko</code> status are fulfilled ) then value <code>gs_alive</code> ( <code>gs_dead</code> in attacker's node ) of son's status is transformed to <code>gs_ko</code>. This operation says: when defender can live after taking the ko ( attacker in son's node is not allowed to recapture the ko, but in his turn pass move "simulating" possible defender's ignoration of ko threat is naturally involved ) then he is alive in ko. And symetrically for the attacker taking the ko. Moreover in defender's node double ko test is performed :<p>
<div class="fragment"><pre class="fragment">      <span class="comment">// double ko handling, ko was taken this turn - possible double ko check  </span>
      <span class="keywordflow">if</span> ( ( ! <a class="code" href="main_8h.html#a2">params_manager</a>.get_no_ko_handling() ) &amp;&amp; (play_ko_for_life &amp;&amp; son_result.group_status == <a class="code" href="eyes_8h.html#a11a3">gs_ko</a> )) { 
        <span class="keywordflow">if</span> ( possible_double_ko ) { <span class="comment">// two independent ko's which white can start -&gt; life</span>
            <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#o0">buff</a> &lt;&lt;  <span class="stringliteral">"Alive in double ko"</span> ; <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#a5">print_comment</a>(<span class="keyword">true</span>);
          son_result.group_status = <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>;
        }
        <span class="keywordflow">else</span> 
          possible_double_ko = <span class="keyword">true</span>;
        <span class="keywordflow">if</span> ( last_move_ko ) { <span class="comment">// last move started ko for life of the group and defender found another one to survive =&gt; double ko</span>
          son_result.group_status = <a class="code" href="eyes_8h.html#a11a4">gs_alive</a>;
          <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#o0">buff</a> &lt;&lt;  <span class="stringliteral">"Alive in double ko"</span> ; <a class="code" href="main_8h.html#a7">sgf_printer</a>.<a class="code" href="classSgf__printer.html#a5">print_comment</a>(<span class="keyword">true</span>);
        }
      }
</pre></div><p>
<a class="anchor" name="invalid"></a><ul>
<li>Gathered status of the son is compared to <code>actual_status_</code> ( the best fitting status so far ) and possible alfa beta cutoff is performed. In this part it is neccessary to take into account accuracy of the actual group status as well( expresed by <code>act_accuracy_</code> of Group_status_accuracy type ). Value <code>gsa_certain</code> accuracy expresses that status represents best play of both players. On the other hand value <code>gsa_alfa_beta_uncertain</code> means that since alfa beta cutoff was performed retrieved group status might be incorrect, however in relation to previous searches and previously set <code>alpha</code> and <code>beta</code> it is satisfying. It is clear that <code>gsa_certain</code> accuracy is prefered to <code>gsa_alpha_beta_uncertain</code>. Thus, algorithm tries to propagate upwards the tree group statuses with <code>gsa_certain</code> accuracy. Therefore, if in one node there are two sons with same group status ( usually this is <code>gs_ko</code> ) and with different accuracies ( <code>gsa_certain</code> and <code>gsa_alfa_beta_uncertain</code> ) than the one with <code>gsa_certain</code> surpasses the second one. As a side note: it is clear that group statuses with uncertain accuracy ( <code>gsa_alfa_beta_uncertain</code> , <code>gsa_depth_uncertain</code> ) are not included in pruned sgf output ( <code>-ps</code> is switched on ), because they might provide confusing information ( human doesn't take into account alfa beta values when browsing search results). This natural part of minimax algorithm with alfa beta pruning is in defender's node ( attacker's node is symmetrical ) programmed as follows:</li></ul>
<p>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (  son_result_.group_status != <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a> &amp;&amp; ( act_status_ &lt;= son_result_.group_status  || act_status_ == <a class="code" href="eyes_8h.html#a11a2">gs_unknown</a> )) {
        <span class="keywordflow">if</span> ( act_status_ == son_result_.group_status ) {
          <span class="keywordflow">if</span> ( act_accuracy_ != <a class="code" href="t__search_8h.html#a13a6">gsa_certain</a> )  <span class="comment">// this is to substitute actual accuracy with better accuracy ( certain )</span>
            act_accuracy_ = son_result_.group_status_accuracy; 
        }
        <span class="keywordflow">else</span>  <span class="comment">// act_status_ &lt; son_result_.group_status</span>
          act_accuracy_ = son_result_.group_status_accuracy; 
      
        act_status_ = son_result_.group_status; 
            
        <span class="keywordflow">if</span> ( ab_pruning &amp;&amp; alfa &lt; act_status_)  <span class="comment">// alfabeta pruning</span>
          alfa = act_status_;
      }

      <span class="comment">// alfa beta cutoff</span>
      <span class="keywordflow">if</span> ( ab_pruning &amp;&amp; ( act_status_ &gt;= beta ) ) { <span class="comment">//pruning</span>
        ...
        <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#a16">unplay_last_stone</a>(); <span class="comment">//unplays son's move </span>
        ... <span class="comment">// storing actual position to transposition table  </span>
        <span class="keywordflow">return</span> act_status_;
      }
</pre></div><p>
<ul>
<li>Actual move is unplayed and another one is tried. This is done by simply calling <a class="el" href="classBoard__manager.html#a16">Board_manager::unplay_last_stone()</a> function and continuing to cycle through the possible moves.</li><li>Returning status of the actual node. Two things must not be forgotten before returning a status ( result of the node ) of the group in the actual node:<ul>
<li>Keeping consistency of the position. This is done by calling <a class="el" href="classBoard__manager.html#a16">Board_manager::unplay_last_stone()</a> function in cases when status of the node is returned before all son's are resolved ( due to some pruning, usually alfa beta ).</li><li>Storing actual position to transposition tables ( only when option <code>-tt</code> is switched on ) with appropriately set input and output alfa beta values together with accuracy of actual result and other information. <div class="fragment"><pre class="fragment">    hash_table_manager.store_item ( <a class="code" href="classHash__table__item.html">Hash_table_item</a> ( <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o2">hash_board_manager</a>.<a class="code" href="classHash__board__manager.html#a2">get_position_hash</a>(), stone_color_to_move_,
                                                      <a class="code" href="board_8h.html#a14">board_manager</a>.<a class="code" href="classBoard__manager.html#o3">ko_manager</a>.<a class="code" href="classKo__manager.html#a2">get_retake_coordinates</a>(),
                                                      in_alfa , in_beta , act_accuracy_ , act_status,  act_status_ )); 
</pre></div></li></ul>
</li></ul>
<h2><a class="anchor" name="page__1_section_2">
Transposition tables implementation</a></h2>
Very close to tree search is the implementation of transposition tables. It is done in <code><a class="el" href="t__search_8cc.html">t_search.cc</a></code> and <code><a class="el" href="t__search_8h.html">t_search.h</a></code>. Transposition tables are handled by class <a class="el" href="classHash__table__manager.html">Hash_table_manager</a> which contains a table representing saved positions and provides functions to perform operations upon the table. Transposition table itself ( <a class="el" href="classHash__table__manager.html#r1">Hash_table_manager::hash_table</a> ) is implemented as an array of pointers to the <a class="el" href="classHash__table__item.html">Hash_table_item</a> ( representing one saved position ). Since today's computers don't struggle with memory shortage as it was usual in the past I decided for fixed-size table with over two million entries ( therefore an empty table takes around 8MB RAM ). During the search process table grows as there are new positions being stored in. Size ( number of items ) of the hash table doesn't change in process of solving Go problem. When a table is rather full ( number of stored position equals number of pointers from Hash_board_manager::hash_table ) then saving mode is toggled on and new positions are stored on the place of old ones. Hashing function is ordinary modulo on the higher bits of position's hash key ( representing the position ). Reason for this is that random generators ( hash key's are made up of random numbers : see <a class="el" href="page_6.html">Position representation</a> ) are "more random" in higher bits. For collision solving typical method of separate chaining is used : each item in the table is a head of a chain containing items with same modulo ( result of hashing function ) of hash key. New items are stored to the end of the chain. When searching for a particular item whole chain ( in the worst case ) must be searched. The key operations upon the table are:<p>
<ul>
<li>Inserting new item into the table ( <a class="el" href="classHash__table__manager.html#a5">Hash_table_manager::store_item</a> ) At first, position's hash key must be normalized by a color of the player to move. This is done according to Zobrist method in function <a class="el" href="classHash__table__manager.html#a4">Hash_table_manager::get_normalized_hash_key()</a>. Then hashing function is applied on the normalized hash key : <div class="fragment"><pre class="fragment">      <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pos = ( item.hash_key &gt;&gt; shift_num ) % hash_table_size;
</pre></div> If saving mod is toggled on ( there are too many positions in the hash table ) then actual position is stored to the first place in the appropriate chain ( replacing some previous position ). Usually ( not in saving mod ) algorithm goes through chain and tries to update some already stored item ( actual item is a "new version" of a position stored previously ) with function hash_board_manager::actualize_item(). When no actualization is done new position is simply stored to the end of the chain.</li></ul>
<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span> ( act_row = 1 ; act_item-&gt;next != NULL ; act_row++ ) {
        <span class="keywordflow">if</span> (  actualize_item (  act_item , item ) ) 
          <span class="keywordflow">return</span>;    <span class="comment">// successfull actualization</span>
        act_item = act_item-&gt;next;
    }
    act_item-&gt;next = <span class="keyword">new</span> <a class="code" href="classHash__table__item.html">Hash_table_item</a> ( item ); <span class="comment">// placing actual position to the end of the chain </span>
</pre></div><p>
<ul>
<li>Retrieving information from the table ( <a class="el" href="classHash__table__manager.html#a6">Hash_table_manager::get_item_status</a> ) As in the previous method position's hash key is normalized and position in the table ( <code>pos</code> ) is retrieved. Then cycle goes through chain of stored items until it reaches the end or it founds corresponding item ( this is decided by applying function <a class="el" href="t__search_8cc.html#a0">corresponds()</a> to both actual and stored item ). Function coorresponds() compares whole ( not shortened by modulo ) hash keys and ko retake coordinates ( this is important : position is determined by it's hash key and position of potential ko ). Moreover it compares input <code>alpha</code> and <code>beta</code> values of both stored position and the actual position ( in the process of tree search ) and takes into account saved position accuracy to decide whether saved output <code>alpha</code> and <code>beta</code> values might be provided for actual position. <div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> ( saved_.accuracy == <a class="code" href="t__search_8h.html#a13a6">gsa_certain</a> ) { <span class="comment">//certain status provides more general condition to apply transposition table cutoff</span>
        <span class="keywordflow">if</span> ( ! ( ( ( saved_.node_type == nt_max ) &amp;&amp; ( ( new_.beta &lt;= saved_.beta ) || ( saved_.new_alfa &lt; saved_.beta )  ) )  || 
             ( ( saved_.node_type == nt_min ) &amp;&amp; ( ( saved_.alfa &lt;= new_.alfa ) || ( saved_.alfa &lt; saved_.new_beta ) ) ) ) ) 
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    } 
    <span class="keywordflow">else</span> <span class="comment">// more resolute conditions, because group status is not certain </span>
      <span class="keywordflow">if</span> ( ! ( ( new_.beta &lt;= saved_.beta ) &amp;&amp; ( saved_.alfa &lt;= new_.alfa ) )  ) 
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
</pre></div> </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed May 24 10:11:22 2006 for TGA by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
